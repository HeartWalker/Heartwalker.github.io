<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeartWalker&#39;s Blog</title>
  <subtitle>萌与正义</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://HeartWalker.cc/"/>
  <updated>2016-08-20T08:18:11.194Z</updated>
  <id>http://HeartWalker.cc/</id>
  
  <author>
    <name>Heart Walker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReactNative之屏幕宽高与像素密度</title>
    <link href="http://HeartWalker.cc/2016/08/20/ReactNative%E4%B9%8B%E5%B1%8F%E5%B9%95%E5%AE%BD%E9%AB%98%E4%B8%8E%E5%83%8F%E7%B4%A0%E5%AF%86%E5%BA%A6/"/>
    <id>http://HeartWalker.cc/2016/08/20/ReactNative之屏幕宽高与像素密度/</id>
    <published>2016-08-20T07:20:38.000Z</published>
    <updated>2016-08-20T08:18:11.194Z</updated>
    
    <content type="html">&lt;p&gt;在React Native中，组件的宽度，高度都是不用写单位的，宽高的数值的单位默认是 dp&lt;/p&gt;
&lt;h3 id=&quot;Dimensions&quot;&gt;&lt;a href=&quot;#Dimensions&quot; class=&quot;headerlink&quot; title=&quot;Dimensions&quot;&gt;&lt;/a&gt;Dimensions&lt;/h3&gt;&lt;p&gt;react-native使用Dimensions来获取设备屏幕的宽和高，使用之前首先引入该模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import {Dimensions} from &amp;apos;react-native&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后就可以使用它&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var {height, width} = Dimensions.get(&amp;apos;window&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取的值的单位都是dp&lt;br&gt;初始的尺寸信息应该在runApplication之后被执行，所以它可以在任何其他的require被执行之前就可用。不过在稍后可能还会更新。&lt;/p&gt;
&lt;p&gt;注意：尽管尺寸信息立即就可用，但它可能会在将来被修改（譬如设备的方向改变），所以基于这些常量的渲染逻辑和样式应当每次render之后都调用此函数，而不是将对应的值保存下来。（举例来说，你可能需要使用内联的样式而不是在StyleSheet中保存相应的尺寸）。&lt;/p&gt;
&lt;h3 id=&quot;PixelRatio&quot;&gt;&lt;a href=&quot;#PixelRatio&quot; class=&quot;headerlink&quot; title=&quot;PixelRatio&quot;&gt;&lt;/a&gt;PixelRatio&lt;/h3&gt;&lt;p&gt;PixelRatio类提供了访问设备的像素密度的方法,使用之前首先引入该模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import {PixelRatio} from &amp;apos;react-native&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PixelRatio.get() 返回设备的像素密度
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;RN中设置一条线的最小高度 不应该用 height：1，而应该使用 1/PixelRatio.get()&lt;/p&gt;
&lt;p&gt;static getPixelSizeForLayoutSize(layoutSize: number)&lt;/p&gt;
&lt;p&gt;将一个布局尺寸(dp)转换为像素尺寸(px)。&lt;/p&gt;
&lt;p&gt;一定会返回一个整数数值。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在React Native中，组件的宽度，高度都是不用写单位的，宽高的数值的单位默认是 dp&lt;/p&gt;
&lt;h3 id=&quot;Dimensions&quot;&gt;&lt;a href=&quot;#Dimensions&quot; class=&quot;headerlink&quot; title=&quot;Dimensions&quot;&gt;&lt;/a&gt;Di
    
    </summary>
    
      <category term="框架" scheme="http://HeartWalker.cc/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react-native" scheme="http://HeartWalker.cc/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative之图片</title>
    <link href="http://HeartWalker.cc/2016/08/16/ReactNative%E4%B9%8B%E5%9B%BE%E7%89%87/"/>
    <id>http://HeartWalker.cc/2016/08/16/ReactNative之图片/</id>
    <published>2016-08-16T14:44:00.000Z</published>
    <updated>2016-08-16T15:01:42.296Z</updated>
    
    <content type="html">&lt;p&gt;source:图片引用地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;网络图片:source={ { uri: &amp;apos;http//xx.png&amp;apos;}}
本地图片:source={require(&amp;apos;./xx.png&amp;apos;)}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你有my-icon.ios.png和my-icon.android.png，Packager就会根据平台而选择不同的文件。&lt;/p&gt;
&lt;p&gt;你还可以使用@2x，@3x这样的文件名后缀，来为不同的屏幕精度提供图片&lt;/p&gt;
&lt;p&gt;注意:为了使新的图片资源机制正常工作,require中图片的名字必须是一个静态字符串, 因为React Native 在编译代码时处理所有的require声明，而不是在运行时的动态处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 正确
&amp;lt;Image source={require(&amp;apos;./my-icon.png&amp;apos;)} /&amp;gt;

// 错误
var icon = this.props.active ? &amp;apos;my-icon-active&amp;apos; : &amp;apos;my-icon-inactive&amp;apos;;
&amp;lt;Image source={require(&amp;apos;./&amp;apos; + icon + &amp;apos;.png&amp;apos;)} /&amp;gt;

// 正确
var icon = this.props.active ? require(&amp;apos;./my-icon-active.png&amp;apos;) : require(&amp;apos;./my-icon-inactive.png&amp;apos;);
&amp;lt;Image source={icon} /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;网络图片需要手动指定尺寸&lt;br&gt;在浏览器中，如果你不给图片指定尺寸，那么浏览器会首先渲染一个0x0大小的元素占位，然后下载图片，在下载完成后再基于正确的尺寸来渲染图片。这样做的最大问题是UI会在图片加载的过程中上下跳动，使得用户体验非常糟糕。&lt;/p&gt;
&lt;p&gt;注意: 在html中只设置宽高的一个,图片会等比例缩放, 但在RN中并不会,因为它会提前渲染宽高,所以在RN中你要同时指定图片的宽高&lt;/p&gt;
&lt;p&gt;在React Native中我们有意避免了这一行为。如此一来开发者就需要做更多工作来提前知晓远程图片的尺寸（或宽高比），但我们相信这样可以带来更好的用户体验。然而，从已经打包好的应用资源文件中读取图片（使用require(‘image!x’)语法）则无需指定尺寸，因为它们的尺寸在加载时就可以立刻知道。&lt;/p&gt;
&lt;p&gt;开发者们常面对的一种需求就是类似web中的背景图（background-image）。要实现这一用例，只需简单地创建一个&lt;image&gt;组件，然后把需要背景图的子组件嵌入其中即可。&lt;/image&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return (
&amp;lt;Image source={...}&amp;gt;
    &amp;lt;Text&amp;gt;Inside&amp;lt;/Text&amp;gt;
&amp;lt;/Image&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;source:图片引用地址&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;网络图片:source={ { uri: &amp;apos;http//xx.png&amp;apos;}}
本地图片:source={require(&amp;apos;./xx.png&amp;apos;)}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;
    
    </summary>
    
      <category term="框架" scheme="http://HeartWalker.cc/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react-native" scheme="http://HeartWalker.cc/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>react之生命周期</title>
    <link href="http://HeartWalker.cc/2016/08/14/react%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://HeartWalker.cc/2016/08/14/react之生命周期/</id>
    <published>2016-08-14T01:48:57.000Z</published>
    <updated>2016-08-14T01:52:02.110Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F_u5206_u4E3A_u4E09_u4E2A_u72B6_u6001&quot;&gt;&lt;a href=&quot;#u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F_u5206_u4E3A_u4E09_u4E2A_u72B6_u6001&quot; class=&quot;headerlink&quot; title=&quot;组件的生命周期分为三个状态&quot;&gt;&lt;/a&gt;组件的生命周期分为三个状态&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Mounting：已插入真实 DOM
Updating：正在被重新渲染
Unmounting：已移出真实 DOM
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u5904_u7406_u51FD_u6570&quot;&gt;&lt;a href=&quot;#u5904_u7406_u51FD_u6570&quot; class=&quot;headerlink&quot; title=&quot;处理函数&quot;&gt;&lt;/a&gt;处理函数&lt;/h3&gt;&lt;p&gt;React 为每个状态都提供了两种处理函数，will函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;componentWillMount()&lt;/p&gt;
&lt;p&gt; 只会在装载之前调用一次，在 render 之前调用，你可以在这个方法里面调用 setState 改变状态，并且不会导致额外调用一次 render&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;componentDidMount()&lt;/p&gt;
&lt;p&gt; 只会在装载完成之后调用一次，在 render 之后调用，从这里开始可以通过 ReactDOM.findDOMNode(this) 获取到组件的 DOM 节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;componentWillUpdate(object nextProps, object nextState)&lt;/p&gt;
&lt;p&gt; 组件实例即将重新渲染时被调用&lt;br&gt; 这个方法在初次渲染时不会被调用。&lt;br&gt; 注意：不能在此方法内调用setState()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;componentDidUpdate(object prevProps, object prevState)&lt;/p&gt;
&lt;p&gt; 组件实例重新渲染后被调用&lt;br&gt; 这个方法在初次渲染时不会被调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;componentWillUnmount()&lt;/p&gt;
&lt;p&gt; 组件实例即将从DOM树移除时被调用&lt;br&gt; 这个方法在整个生命周期中只会被调用一次。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外，React 还提供两种特殊状态的处理函数。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;componentWillReceiveProps(object nextProps)&lt;/p&gt;
&lt;p&gt; 已加载组件收到新的参数时调用,参数nextProps表示即将应用到组件实例上的新属性值。这个方法在初次渲染时不会被调用。在此方法内调用setState()不会引起重新渲染。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;shouldComponentUpdate(object nextProps, object nextState)&lt;/p&gt;
&lt;p&gt; 组件实例即将重新渲染时被调用&lt;br&gt; 参数nextProps传入即将应用到组件实例上的新属性值，参数nextState传入组件实例即将被 设置的状态值。如果这个方法返回false，那么组件实例就不会被重新渲染。除非我们明确地 知道，新的属性和状态不需要进行重新渲染，否则这个方法都应该返回true。&lt;br&gt; 这个方法在初次渲染时或通过forceUpdate()方法进行渲染时不会被调用。&lt;/p&gt;
&lt;h3 id=&quot;u6D41_u7A0B_u56FE&quot;&gt;&lt;a href=&quot;#u6D41_u7A0B_u56FE&quot; class=&quot;headerlink&quot; title=&quot;流程图&quot;&gt;&lt;/a&gt;流程图&lt;/h3&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/549190/201603/549190-20160320001355490-136229096.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F_u5206_u4E3A_u4E09_u4E2A_u72B6_u6001&quot;&gt;&lt;a href=&quot;#u7EC4_u4EF6_u7684_u751F_u547D_u5468_u671F_u
    
    </summary>
    
      <category term="框架" scheme="http://HeartWalker.cc/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="react" scheme="http://HeartWalker.cc/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>ESMA6入门之set与map</title>
    <link href="http://HeartWalker.cc/2016/08/07/ESMA6%E5%85%A5%E9%97%A8%E4%B9%8Bset%E4%B8%8Emap/"/>
    <id>http://HeartWalker.cc/2016/08/07/ESMA6入门之set与map/</id>
    <published>2016-08-07T03:31:20.000Z</published>
    <updated>2016-08-07T03:32:19.601Z</updated>
    
    <content type="html">&lt;p&gt;手打,学习,来自阮一峰的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;br&gt;想要学 node.js 与最新的框架 ,最好先学ES6&lt;/p&gt;
&lt;h2 id=&quot;set&quot;&gt;&lt;a href=&quot;#set&quot; class=&quot;headerlink&quot; title=&quot;set&quot;&gt;&lt;/a&gt;set&lt;/h2&gt;&lt;h3 id=&quot;u57FA_u672C_u7528_u6CD5&quot;&gt;&lt;a href=&quot;#u57FA_u672C_u7528_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;&lt;p&gt;ES6提供了新的数据结构Set. 它类似数组, 但是成员的值都是唯一的, 没有重复值.&lt;br&gt;Set本身是一个构造函数, 用来生成Set数据结构&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s = new Set();

[2,3,5,4,5,2,2].map(x = &amp;gt; s.add(x));
for(let i of s){
    console.log(i);
}
//2 3 5 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码通过add方法向Set结构加入成员, 结构表明Set结构不会添加重复的值.&lt;br&gt;Set函数可以接受一个数组(或列斯数组的对象)作为参数,用来初始化.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//例1
var set = new Set([1,2,3,4,5]);
[...set]
//例2
var items = new Set([1,2,3,4,5,5,5,5,5]);
items.size//5
//例三
function divs() {
    return [...document.querySelectorAll(&amp;apos;div&amp;apos;)];
}
var set = new Set(divs());
set.size
//类似于
divs().forEach(div =&amp;gt; set.add(div));
set.size
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 例一和例二都是Set函数接受数组作为参数,例三是接受类似数组的对象作为参数.&lt;br&gt;上面代码中, 也展示了一种去除数组重复成员的方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//去除数组的重复成员
[...new Set(array)]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向Set加入值得时候, 不会发生类型转换, 所以5和”5”是两个不同的值. Set内部判断两个值是否不同, 使用的算法加做”Same-value equality”, 它类似于精确相等运算符(===), 主要的区别是 NaN等于自身, 而精确相等运算符认为NaN不等于自身.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set //Set{NaN}        
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另外, 两个对象总是不相等的.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let set = new Set();
set.add({});
set.size //1
set.add({});
set.size //2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;Set_u5B9E_u4F8B_u7684_u5C5E_u6027_u548C_u65B9_u6CD5&quot;&gt;&lt;a href=&quot;#Set_u5B9E_u4F8B_u7684_u5C5E_u6027_u548C_u65B9_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;Set实例的属性和方法&quot;&gt;&lt;/a&gt;Set实例的属性和方法&lt;/h3&gt;&lt;p&gt;Set结构的实例有以下属性.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- Set.prototype.constructor:构造函数, 默认就是Set函数.    
- Set.prototype.size: 返回Set实例的成员总数.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Set实例的方法分为两大类:操作方法（用于操作数据）和遍历方法（用于遍历成员）．下面先介绍四个操作方法．&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- add(value):添加某个值, 返回Set结构本身
- delete(value):删除某个值, 返回一个布尔值, 表示删除是否成功
- has(value):返回一个布尔值, 表示 改制是否为Set的成员.
- clear():清除所有成员, 没有返回值. 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这些属性和方法的实例如下.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s.add(1).add(2).add(2)
//注意2被加入了两次
s.size //2
s.has(1)//true
s.has(2)//true 
s.has(3)/false

s.delete(2);
s.has(2) //false
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是一个对比, 看看在判断是否包括一个键上面, Object结构和Set结构的写法的不同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//对象写法
var properties = {
    &amp;apos;width&amp;apos;:1,
    &amp;apos;height&amp;apos;:1
};
if (properties[someName]){
    //do something
}

//Set的写法
var properties = new Set();
properties.add(&amp;apos;width&amp;apos;);
properties.add(&amp;apos;height&amp;apos;);

if (properties.has(someName)){
    //do something
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Array.from方法可以讲Set结构转化为数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var iterm = new Set([1, 2,3, 4, 5]);
var array = Array.from(items);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就提供了去除数组重复成员的另一种方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function dedupe(array){
    return Array.from(new Set(array));
}      
dedupe([1, 1, 2, 3]) //[1, 2, 3]  
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u904D_u5386_u64CD_u4F5C&quot;&gt;&lt;a href=&quot;#u904D_u5386_u64CD_u4F5C&quot; class=&quot;headerlink&quot; title=&quot;遍历操作&quot;&gt;&lt;/a&gt;遍历操作&lt;/h3&gt;&lt;p&gt;Set结构的实例有四个遍历方法, 可以用于遍历成员. &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- keys():返回键名的遍历器
- values():返回键值得遍历器
- entries(): 返回键值对的遍历器
- forEach(): 使用回调函数遍历每个成员
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要特别指出的是, Set的遍历顺序就是插入书序. 这个特性有时候非常有用, 比如使用Set保存一个回调函数列表, 调用时就能保证按照顺序调用.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;keys(), values(), entries()&lt;br&gt;key方法 value方法 entries方法返回的都是遍历器对象. 由于Set结构没有键名, 只有键值(或者说键名与键值是同一个值), 所以key方法和value方法的行为完全一致.&lt;/p&gt;
&lt;p&gt; let set = new Set([‘red’, ‘green’,’blue’]);&lt;br&gt; for(let item of set.keys()){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(item);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; //red&lt;br&gt; //green&lt;br&gt; //blue&lt;/p&gt;
&lt;p&gt; for (let item of set.values()){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(item);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; //red&lt;br&gt; //green&lt;br&gt; //blue&lt;/p&gt;
&lt;p&gt; for (let item of set.entries()){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(item); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; //[“red”,”red”]&lt;br&gt; //[“green”,”green”]&lt;br&gt; //[“blue”,”blue”]&lt;br&gt;上面代码中, entries方法返回的遍历器, 同时包括键名和键值, 所以没输出一个数组, 他的两个成员完全相等.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Set结构的实例默认可遍历, 他的默认遍历器生成的函数就是他的values方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set.prototype[Symbol.iterator] === Set.prototype.values
//true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这意味着, 可以省略values方法, 直接用for…of循环遍历Set&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let set = new Set([&amp;apos;red&amp;apos;,&amp;apos;green&amp;apos;,&amp;apos;blue&amp;apos;]);
for (let x of set){
    console.log(x);
}    
//red
//green
//blue
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;forEach()&lt;br&gt;Set结构的实例的forEach方法, 用于对每个成员执行某种操作, 没有返回值.&lt;/p&gt;
&lt;p&gt; let set = new Set([1,2,3]);&lt;br&gt; set.forEach((value,key) =&amp;gt; console.log(value*2));&lt;br&gt; //2&lt;br&gt; //4&lt;br&gt; //6&lt;br&gt;上面代码说明, forEach方法的参数就是一个处理函数. 该函数的参数依次为键值, 见之明, 集合本身(上例省略了该参数). 另外, forEach方法还可以有第二个参数, 表示绑定的this对象.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;遍历的应用&lt;br&gt;扩展运算符(…)内部使用for…of循环, 所以也可以是用Set结构.&lt;/p&gt;
&lt;p&gt; let set = new Set([‘red’, ‘green’,’blue’]);&lt;br&gt; let arr = […set];&lt;br&gt; //[‘red’,’green’,’blue’]&lt;br&gt;扩展运算符和Set结构相结合, 就可以去除数组的重复成员.&lt;/p&gt;
&lt;p&gt; let arr = [3,5,2,2,5,5];&lt;br&gt; let unique = […new Set(arr)];&lt;br&gt; //[3,5,2]&lt;br&gt;而且, 数组的map和filter方法也可以用于Set了.   &lt;/p&gt;
&lt;p&gt; let set= new Set([1,2,3]);&lt;br&gt; set = new Set([…set].map(x =&amp;gt; x*2));&lt;br&gt; //返回Set结构{2, 4, 6}      &lt;/p&gt;
&lt;p&gt; let set = new Set([1, 2, 3, 4, 5]);&lt;br&gt; set = new Set([…set].filter(x =&amp;gt; (x % 2) == 0));&lt;br&gt; //返回Set结构:{2 , 4}&lt;br&gt;因此使用Set可以很容易地实现并集(Union), 交集(Interse)和差集(difference).&lt;/p&gt;
&lt;p&gt; let a = new Set([1, 2, 3]);&lt;br&gt; let b = new Set([4, 3, 2]);&lt;/p&gt;
&lt;p&gt; //并集&lt;br&gt; let union = new Set([…a, …b]);&lt;br&gt; union //Set {1 ,2 ,3 ,4 }&lt;br&gt; // 交集&lt;br&gt; let intersect = new Set([…a].filter(x =&amp;gt; b.has(x)));&lt;br&gt; //Set {2, 3}&lt;br&gt; //差集&lt;br&gt; let difference = new Set([…a].filter(x =&amp;gt; !b.has(x)));&lt;br&gt; // Set {1}&lt;br&gt;如果想在遍历操作中, 同步改变原来的Set结构, 目前没有直接的方法, 但有两种变通方法. 一种是利用原&lt;br&gt;Set结构映射出一个新的结构, 然后赋值给原来的Set结构; 另一种是利用Array.from方法.&lt;/p&gt;
&lt;p&gt; //方法一&lt;br&gt; let set = new Set([1, 2, 3]);&lt;br&gt; set = new Set([…set].map(val =&amp;gt; val * 2));&lt;br&gt; //set的值是2, 4, 6&lt;/p&gt;
&lt;p&gt; //方法三&lt;br&gt; let set = new Set([1, 2, 3]);&lt;br&gt; set = new Set(Array.from(set, val =&amp;gt; val * 2));&lt;br&gt;上面代码提供了两种方法, 直接在遍历操作中改变原来的Set结构.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;WeakSet&quot;&gt;&lt;a href=&quot;#WeakSet&quot; class=&quot;headerlink&quot; title=&quot;WeakSet&quot;&gt;&lt;/a&gt;WeakSet&lt;/h2&gt;&lt;p&gt;WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。&lt;/p&gt;
&lt;p&gt;首先，WeakSet的成员只能是对象，而不能是其他类型的值。&lt;/p&gt;
&lt;p&gt;其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码试图向WeakSet添加一个数值和Symbol值，结果报错，因为WeakSet只能放置对象。&lt;/p&gt;
&lt;p&gt;WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ws = new WeakSet();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = [[1,2], [3,4]];
var ws = new WeakSet(a);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。&lt;/p&gt;
&lt;p&gt;注意，是a数组的成员成为WeakSet的成员，而不是a数组本身。这意味着，数组的成员只能是对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var b = [3, 4];
var ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，数组b的成员不是对象，加入WeaKSet就会报错。&lt;/p&gt;
&lt;p&gt;WeakSet结构有以下三个方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。
WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。
WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面是一个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var ws = new WeakSet();
var obj = {};
var foo = {};

ws.add(window);
ws.add(obj);

ws.has(window); // true
ws.has(foo);    // false

ws.delete(window);
ws.has(window);    // false

WeakSet没有size属性，没有办法遍历它的成员。

ws.size // undefined
ws.forEach // undefined

ws.forEach(function(item){ console.log(&amp;apos;WeakSet has &amp;apos; + item)})
// TypeError: undefined is not a function
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码试图获取size和forEach属性，结果都不能成功。&lt;/p&gt;
&lt;p&gt;WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。&lt;/p&gt;
&lt;p&gt;下面是WeakSet的另一个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const foos = new WeakSet()
class Foo {
  constructor() {
    foos.add(this)
  }
  method () {
    if (!foos.has(this)) {
      throw new TypeError(&amp;apos;Foo.prototype.method 只能在Foo的实例上调用！&amp;apos;);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。&lt;/p&gt;
&lt;h2 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h2&gt;&lt;h3 id=&quot;Map_u7ED3_u6784_u7684_u76EE_u7684_u548C_u57FA_u672C_u7528_u6CD5&quot;&gt;&lt;a href=&quot;#Map_u7ED3_u6784_u7684_u76EE_u7684_u548C_u57FA_u672C_u7528_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;Map结构的目的和基本用法&quot;&gt;&lt;/a&gt;Map结构的目的和基本用法&lt;/h3&gt;&lt;p&gt;JavaScript的对象(Object), 本质上是键值对的集合(Hash结构), 但是传统上只能用字符串当做键. 这给它的使用带来了很大的限制.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var data = {};
var element = document.getElementById(&amp;quot;myDiv&amp;quot;);

data[element] = &amp;quot;metadata&amp;quot;;
data[&amp;quot;[object HTMLDivElement]&amp;quot;] // metadata
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var m = new Map();
var o = {p: &amp;quot;Hello World&amp;quot;};

m.set(o, &amp;quot;content&amp;quot;)
m.get(o) // &amp;quot;content&amp;quot;

m.has(o) // true
m.delete(o) // true
m.has(o) // false
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码使用set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。&lt;/p&gt;
&lt;p&gt;作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var map = new Map([[&amp;apos;name&amp;apos;, &amp;apos;张三&amp;apos;], [&amp;apos;title&amp;apos;, &amp;apos;Author&amp;apos;]]);

map.size // 2
map.has(&amp;apos;name&amp;apos;) // true
map.get(&amp;apos;name&amp;apos;) // &amp;quot;张三&amp;quot;
map.has(&amp;apos;title&amp;apos;) // true
map.get(&amp;apos;title&amp;apos;) // &amp;quot;Author&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码在新建Map实例时，就指定了两个键name和title。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Map构造函数接受数组作为参数，实际上执行的是下面的算法。

var items = [
  [&amp;apos;name&amp;apos;, &amp;apos;张三&amp;apos;],
  [&amp;apos;title&amp;apos;, &amp;apos;Author&amp;apos;]
];
var map = new Map();
items.forEach(([key, value]) =&amp;gt; map.set(key, value));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果对同一个键多次赋值，后面的值将覆盖前面的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = new Map();

map
.set(1, &amp;apos;aaa&amp;apos;)
.set(1, &amp;apos;bbb&amp;apos;);

map.get(1) // &amp;quot;bbb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码对键1连续赋值两次，后一次的值覆盖前一次的值。&lt;/p&gt;
&lt;p&gt;如果读取一个未知的键，则返回undefined。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Map().get(&amp;apos;asfddfsasadf&amp;apos;)
// undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。&lt;br&gt;    var map = new Map();&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map.set([&amp;apos;a&amp;apos;], 555);
map.get([&amp;apos;a&amp;apos;]) // undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。&lt;/p&gt;
&lt;p&gt;同理，同样的值的两个实例，在Map结构中被视为两个键。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var map = new Map();

var k1 = [&amp;apos;a&amp;apos;];
var k2 = [&amp;apos;a&amp;apos;];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，变量k1和k2的值是一样的，但是它们在Map结构中被视为两个键。&lt;/p&gt;
&lt;p&gt;由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。&lt;/p&gt;
&lt;p&gt;如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = new Map();

map.set(NaN, 123);
map.get(NaN) // 123

map.set(-0, 123);
map.get(+0) // 123
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u5B9E_u4F8B_u7684_u5C5E_u6027_u548C_u64CD_u4F5C_u65B9_u6CD5&quot;&gt;&lt;a href=&quot;#u5B9E_u4F8B_u7684_u5C5E_u6027_u548C_u64CD_u4F5C_u65B9_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;实例的属性和操作方法&quot;&gt;&lt;/a&gt;实例的属性和操作方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;size属性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;size属性返回Map结构的成员总数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = new Map();
map.set(&amp;apos;foo&amp;apos;, true);
map.set(&amp;apos;bar&amp;apos;, false);

map.size // 2
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;set(key, value)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var m = new Map();

m.set(&amp;quot;edition&amp;quot;, 6)        // 键是字符串
m.set(262, &amp;quot;standard&amp;quot;)     // 键是数值
m.set(undefined, &amp;quot;nah&amp;quot;)    // 键是undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;set方法返回的是Map本身，因此可以采用链式写法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = new Map()
  .set(1, &amp;apos;a&amp;apos;)
  .set(2, &amp;apos;b&amp;apos;)
  .set(3, &amp;apos;c&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;get(key)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;get方法读取key对应的键值，如果找不到key，返回undefined。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var m = new Map();

var hello = function() {console.log(&amp;quot;hello&amp;quot;);}
m.set(hello, &amp;quot;Hello ES6!&amp;quot;) // 键是函数

m.get(hello)  // Hello ES6!
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;has(key)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;has方法返回一个布尔值，表示某个键是否在Map数据结构中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var m = new Map();

m.set(&amp;quot;edition&amp;quot;, 6);
m.set(262, &amp;quot;standard&amp;quot;);
m.set(undefined, &amp;quot;nah&amp;quot;);

m.has(&amp;quot;edition&amp;quot;)     // true
m.has(&amp;quot;years&amp;quot;)       // false
m.has(262)           // true
m.has(undefined)     // true
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;delete(key)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;delete方法删除某个键，返回true。如果删除失败，返回false。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var m = new Map();
m.set(undefined, &amp;quot;nah&amp;quot;);
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;clear()&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;clear方法清除所有成员，没有返回值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = new Map();
map.set(&amp;apos;foo&amp;apos;, true);
map.set(&amp;apos;bar&amp;apos;, false);

map.size // 2
map.clear()
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u904D_u5386_u65B9_u6CD5&quot;&gt;&lt;a href=&quot;#u904D_u5386_u65B9_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;遍历方法&quot;&gt;&lt;/a&gt;遍历方法&lt;/h3&gt;&lt;p&gt;Map原生提供三个遍历器生成函数和一个遍历方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;keys()：返回键名的遍历器。
values()：返回键值的遍历器。
entries()：返回所有成员的遍历器。
forEach()：遍历Map的所有成员。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要特别注意的是，Map的遍历顺序就是插入顺序。&lt;/p&gt;
&lt;p&gt;下面是使用实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = new Map([
  [&amp;apos;F&amp;apos;, &amp;apos;no&amp;apos;],
  [&amp;apos;T&amp;apos;,  &amp;apos;yes&amp;apos;],
]);

for (let key of map.keys()) {
  console.log(key);
}
// &amp;quot;F&amp;quot;
// &amp;quot;T&amp;quot;

for (let value of map.values()) {
  console.log(value);
}
// &amp;quot;no&amp;quot;
// &amp;quot;yes&amp;quot;

for (let item of map.entries()) {
  console.log(item[0], item[1]);
}
// &amp;quot;F&amp;quot; &amp;quot;no&amp;quot;
// &amp;quot;T&amp;quot; &amp;quot;yes&amp;quot;

// 或者
for (let [key, value] of map.entries()) {
  console.log(key, value);
}

// 等同于使用map.entries()
for (let [key, value] of map) {
  console.log(key, value);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码最后的那个例子，表示Map结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map[Symbol.iterator] === map.entries
// true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（…）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = new Map([
  [1, &amp;apos;one&amp;apos;],
  [2, &amp;apos;two&amp;apos;],
  [3, &amp;apos;three&amp;apos;],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// [&amp;apos;one&amp;apos;, &amp;apos;two&amp;apos;, &amp;apos;three&amp;apos;]

[...map.entries()]
// [[1,&amp;apos;one&amp;apos;], [2, &amp;apos;two&amp;apos;], [3, &amp;apos;three&amp;apos;]]

[...map]
// [[1,&amp;apos;one&amp;apos;], [2, &amp;apos;two&amp;apos;], [3, &amp;apos;three&amp;apos;]]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map0 = new Map()
  .set(1, &amp;apos;a&amp;apos;)
  .set(2, &amp;apos;b&amp;apos;)
  .set(3, &amp;apos;c&amp;apos;);

let map1 = new Map(
  [...map0].filter(([k, v]) =&amp;gt; k &amp;lt; 3)
);
// 产生Map结构 {1 =&amp;gt; &amp;apos;a&amp;apos;, 2 =&amp;gt; &amp;apos;b&amp;apos;}

let map2 = new Map(
  [...map0].map(([k, v]) =&amp;gt; [k * 2, &amp;apos;_&amp;apos; + v])
    );
// 产生Map结构 {2 =&amp;gt; &amp;apos;_a&amp;apos;, 4 =&amp;gt; &amp;apos;_b&amp;apos;, 6 =&amp;gt; &amp;apos;_c&amp;apos;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map.forEach(function(value, key, map)) {
  console.log(&amp;quot;Key: %s, Value: %s&amp;quot;, key, value);
};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;forEach方法还可以接受第二个参数，用来绑定this。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var reporter = {
  report: function(key, value) {
    console.log(&amp;quot;Key: %s, Value: %s&amp;quot;, key, value);
  }
};

map.forEach(function(value, key, map) {
  this.report(key, value);
}, reporter);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，forEach方法的回调函数的this，就指向reporter。&lt;/p&gt;
&lt;h3 id=&quot;u4E0E_u5176_u4ED6_u6570_u636E_u7ED3_u6784_u7684_u4E92_u76F8_u8F6C_u6362&quot;&gt;&lt;a href=&quot;#u4E0E_u5176_u4ED6_u6570_u636E_u7ED3_u6784_u7684_u4E92_u76F8_u8F6C_u6362&quot; class=&quot;headerlink&quot; title=&quot;与其他数据结构的互相转换&quot;&gt;&lt;/a&gt;与其他数据结构的互相转换&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Map转为数组&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let myMap = new Map().set(true, 7).set({foo: 3}, [&amp;apos;abc&amp;apos;]);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ &amp;apos;abc&amp;apos; ] ] ]
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;数组转为Map&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;将数组转入Map构造函数，就可以转为Map。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Map([[true, 7], [{foo: 3}, [&amp;apos;abc&amp;apos;]]])
// Map {true =&amp;gt; 7, Object {foo: 3} =&amp;gt; [&amp;apos;abc&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;Map转为对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果所有Map的键都是字符串，它可以转为对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

let myMap = new Map().set(&amp;apos;yes&amp;apos;, true).set(&amp;apos;no&amp;apos;, false);
strMapToObj(myMap)
// { yes: true, no: false }
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对象转为Map&lt;/p&gt;
&lt;p&gt; function objToStrMap(obj) {&lt;br&gt;   let strMap = new Map();&lt;br&gt;   for (let k of Object.keys(obj)) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;strMap.set(k, obj[k]);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   }&lt;br&gt;   return strMap;&lt;br&gt; }&lt;/p&gt;
&lt;p&gt; objToStrMap({yes: true, no: false})&lt;br&gt; // Map {“yes” =&amp;gt; true, “no” =&amp;gt; false}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Map转为JSON&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set(&amp;apos;yes&amp;apos;, true).set(&amp;apos;no&amp;apos;, false);
strMapToJson(myMap)
// &amp;apos;{&amp;quot;yes&amp;quot;:true,&amp;quot;no&amp;quot;:false}&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({foo: 3}, [&amp;apos;abc&amp;apos;]);
mapToArrayJson(myMap)
// &amp;apos;[[true,7],[{&amp;quot;foo&amp;quot;:3},[&amp;quot;abc&amp;quot;]]]&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;JSON转为Map&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JSON转为Map，正常情况下，所有键名都是字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap(&amp;apos;{&amp;quot;yes&amp;quot;:true,&amp;quot;no&amp;quot;:false}&amp;apos;)
// Map {&amp;apos;yes&amp;apos; =&amp;gt; true, &amp;apos;no&amp;apos; =&amp;gt; false}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap(&amp;apos;[[true,7],[{&amp;quot;foo&amp;quot;:3},[&amp;quot;abc&amp;quot;]]]&amp;apos;)
// Map {true =&amp;gt; 7, Object {foo: 3} =&amp;gt; [&amp;apos;abc&amp;apos;]}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;WeakMap&quot;&gt;&lt;a href=&quot;#WeakMap&quot; class=&quot;headerlink&quot; title=&quot;WeakMap&quot;&gt;&lt;/a&gt;WeakMap&lt;/h2&gt;&lt;p&gt;(验证不出来啊 , 不理解)&lt;br&gt;WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var map = new WeakMap()
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，如果将1和Symbol作为WeakMap的键名，都会报错。&lt;/p&gt;
&lt;p&gt;WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。&lt;/p&gt;
&lt;p&gt;下面是WeakMap结构的一个例子，可以看到用法上与Map几乎一样。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var wm = new WeakMap();
var element = document.querySelector(&amp;quot;.element&amp;quot;);

wm.set(element, &amp;quot;Original&amp;quot;);
wm.get(element) // &amp;quot;Original&amp;quot;

element.parentNode.removeChild(element);
element = null;
wm.get(element) // undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，变量wm是一个WeakMap实例，我们将一个DOM节点element作为键名，然后销毁这个节点，element对应的键就自动消失了，再引用这个键名就返回undefined。&lt;/p&gt;
&lt;p&gt;WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var wm = new WeakMap();

wm.size
// undefined

wm.forEach
// undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前文说过，WeakMap应用的典型场合就是DOM节点作为键名。下面是一个例子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let myElement = document.getElementById(&amp;apos;logo&amp;apos;);
let myWeakmap = new WeakMap();

myWeakmap.set(myElement, {timesClicked: 0});

myElement.addEventListener(&amp;apos;click&amp;apos;, function() {
  let logoData = myWeakmap.get(myElement);
  logoData.timesClicked++;
  myWeakmap.set(myElement, logoData);
}, false);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，myElement是一个DOM节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在WeakMap里，对应的键名就是myElement。一旦这个DOM节点删除，该状态就会自动消失，不存在内存泄漏风险。&lt;/p&gt;
&lt;p&gt;WeakMap的另一个用处是部署私有属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let _counter = new WeakMap();
let _action = new WeakMap();

class Countdown {
  constructor(counter, action) {
    _counter.set(this, counter);
    _action.set(this, action);
  }
  dec() {
    let counter = _counter.get(this);
    if (counter &amp;lt; 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter === 0) {
      _action.get(this)();
    }
  }
}

let c = new Countdown(2, () =&amp;gt; console.log(&amp;apos;DONE&amp;apos;));

c.dec()
c.dec()
// DONE
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。    &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;手打,学习,来自阮一峰的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;br&gt;想要学 node.js 与最新的框架 ,最好先学ES6&lt;/p&gt;
&lt;h2 id=&quot;set&quot;&gt;&lt;a
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="ECMA6" scheme="http://HeartWalker.cc/tags/ECMA6/"/>
    
  </entry>
  
  <entry>
    <title>EDM编码规范</title>
    <link href="http://HeartWalker.cc/2016/08/01/EDM%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://HeartWalker.cc/2016/08/01/EDM编码规范/</id>
    <published>2016-08-01T14:12:01.000Z</published>
    <updated>2016-08-01T14:18:24.841Z</updated>
    
    <content type="html">&lt;p&gt;最近做项目需要做邮件营销, 写了一些EDM, 收集整理了一些规范&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Html 编码请使用utf-8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Table需要单独新建以便控制邮件中的布局&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Table的tr不设置任何样式和属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;所有样式都写到行内&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在制作edm中不能设置margin值,float值，及热点map&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Table属性中如若设置背景图只能给td加，背景图需要宽跟高,谨记background以属性方式写不能以style样式写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Img图片的插入要设置宽跟高及border=”0”并且样式中设置display：block;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个Table中需设置 border=”0” align=”center” cellpadding=”0” cellspacing=”0”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;td的图片不居顶对齐可以对td设置valign=”top”（middle，bottom）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;超链接a标签需title属性， img标签需alt属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;td中的colspan和rowspan的合理使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;页面中不能出现空的&lt;td&gt;&lt;/td&gt;&lt;td&gt;需写成”&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;“否则邮箱解析html代码整个td都会过滤掉&lt;/td&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;edm制作中不要使用h2，ul，li，p，ol等有默认样式的标签，&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近做项目需要做邮件营销, 写了一些EDM, 收集整理了一些规范&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Html 编码请使用utf-8&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Table需要单独新建以便控制邮件中的布局&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Table的tr不设置任何样式和
    
    </summary>
    
      <category term="东成西就" scheme="http://HeartWalker.cc/categories/%E4%B8%9C%E6%88%90%E8%A5%BF%E5%B0%B1/"/>
    
    
      <category term="edm" scheme="http://HeartWalker.cc/tags/edm/"/>
    
  </entry>
  
  <entry>
    <title>ECMA6入门之字符串的扩展</title>
    <link href="http://HeartWalker.cc/2016/07/25/ECMA6%E5%85%A5%E9%97%A8%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://HeartWalker.cc/2016/07/25/ECMA6入门之字符串的扩展/</id>
    <published>2016-07-25T14:26:10.000Z</published>
    <updated>2016-08-01T14:28:04.491Z</updated>
    
    <content type="html">&lt;p&gt;手打,学习,来自阮一峰的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;br&gt;想要学 node.js 与最新的框架 ,最好先学ES6&lt;/p&gt;
&lt;h2 id=&quot;u5B57_u7B26_u4E32_u7684_u6269_u5C55&quot;&gt;&lt;a href=&quot;#u5B57_u7B26_u4E32_u7684_u6269_u5C55&quot; class=&quot;headerlink&quot; title=&quot;字符串的扩展&quot;&gt;&lt;/a&gt;字符串的扩展&lt;/h2&gt;&lt;h3 id=&quot;includes_28_29_2CstratsWith_28_29_2CendsWith_28_29&quot;&gt;&lt;a href=&quot;#includes_28_29_2CstratsWith_28_29_2CendsWith_28_29&quot; class=&quot;headerlink&quot; title=&quot;includes(),stratsWith(),endsWith()&quot;&gt;&lt;/a&gt;includes(),stratsWith(),endsWith()&lt;/h3&gt;&lt;p&gt;ES5中,JavaScript有indexOf方法与lastIndexOf()方法, 可以用来确定一个字符串是否包含在另一个字符串中. ES6又提供了三种新方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;includes(): 返回布尔值, 表示是否找到了参数字符串.
startsWith(): 返回布尔值, 表示参数字符串是否在原字符串的头部
endsWith(): 返回布尔值, 表示参数字符串是否在源字符串的尾部

var s = &amp;quot;Hellow world!&amp;quot;;
s.startsWith(&amp;apos;Hellow&amp;apos;)//true
s.endsWith(&amp;apos;!&amp;apos;)//true
s.includes(&amp;apos;o&amp;apos;)//true     
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这三个方法都支持第二个参数, 表示开始搜索的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s = &amp;apos;Hello world!&amp;apos;;
s.startsWith(&amp;apos;word&amp;apos;, 6) //true
s.endsWith(&amp;apos;Hello&amp;apos;, 5) //true
s.includes(&amp;apos;Hello&amp;apos;, 6) //false
上面代码表示, 使用第二个参数n时,endsWith的行为与其他两个方法有所不同. 它针对前n个字符, 而其它两个方法针对从第n个位置直到字符串结束
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;repeat_28_29&quot;&gt;&lt;a href=&quot;#repeat_28_29&quot; class=&quot;headerlink&quot; title=&quot;repeat()&quot;&gt;&lt;/a&gt;repeat()&lt;/h3&gt;&lt;p&gt;repeat方法返回一个新字符串, 表示将原字符串重复n次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;x&amp;apos;.repeat(3)//&amp;quot;xxx&amp;quot;
&amp;apos;hello&amp;apos;.repeat(2) //&amp;quot;hellohello&amp;quot;
&amp;apos;na&amp;apos;.repeat(0) //&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是小数,会被取整&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;na&amp;apos;.repeat(2.9)//&amp;quot;nana&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果repeat的参数时负数或者Infinity或undefined, 会报错.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;na&amp;apos;.repeat(Infinity)
//RangeErrow
&amp;apos;na&amp;apos;.repeat(-1)
//RangeError
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是, 如果蚕食是0 到-1之间的小数, 则等同于0, 这是因为会先进行取整原酸, 0 到-1之间的小数, 取整以后等于-0, repeat视同为0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;na&amp;apos;.repeat(-0.9)   //&amp;quot;&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数NaN等同于0&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;na&amp;apos;.repeat(NaN)//&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果repeat的参数时字符串, 则会先转换成数字.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;na&amp;apos;.repeat(&amp;apos;na&amp;apos;)//&amp;quot;&amp;quot;
&amp;apos;na&amp;apos;.repeat(&amp;apos;3&amp;apos;)//&amp;quot;nanana&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;padStart_28_29_2CpadEnd_28_29&quot;&gt;&lt;a href=&quot;#padStart_28_29_2CpadEnd_28_29&quot; class=&quot;headerlink&quot; title=&quot;padStart(),padEnd()&quot;&gt;&lt;/a&gt;padStart(),padEnd()&lt;/h3&gt;&lt;p&gt;ES7推出了字符串补全长度的功能.如果某个字符串不够指定长度, 会在头部或尾部补全. padStrat用于头部补全, padEnd用于尾部补全&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;x&amp;apos;.padStart(5, &amp;apos;ab&amp;apos;) // &amp;apos;ababx&amp;apos;
&amp;apos;x&amp;apos;.padStart(4, &amp;apos;ab&amp;apos;) // &amp;apos;abax&amp;apos;

&amp;apos;x&amp;apos;.padEnd(5, &amp;apos;ab&amp;apos;) // &amp;apos;xabab&amp;apos;
&amp;apos;x&amp;apos;.padEnd(4, &amp;apos;ab&amp;apos;) // &amp;apos;xaba&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。&lt;/p&gt;
&lt;p&gt;如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;xxx&amp;apos;.padStart(2, &amp;apos;ab&amp;apos;) // &amp;apos;xxx&amp;apos;
&amp;apos;xxx&amp;apos;.padEnd(2, &amp;apos;ab&amp;apos;) // &amp;apos;xxx&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;abc&amp;apos;.padStart(10, &amp;apos;0123456789&amp;apos;)
// &amp;apos;0123456abc&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果省略第二个参数，则会用空格补全长度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;x&amp;apos;.padStart(4) // &amp;apos;   x&amp;apos;
&amp;apos;x&amp;apos;.padEnd(4) // &amp;apos;x   &amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;1&amp;apos;.padStart(10, &amp;apos;0&amp;apos;) // &amp;quot;0000000001&amp;quot;
&amp;apos;12&amp;apos;.padStart(10, &amp;apos;0&amp;apos;) // &amp;quot;0000000012&amp;quot;
&amp;apos;123456&amp;apos;.padStart(10, &amp;apos;0&amp;apos;) // &amp;quot;0000123456&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一个用途是提示字符串格式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;apos;12&amp;apos;.padStart(10, &amp;apos;YYYY-MM-DD&amp;apos;) // &amp;quot;YYYY-MM-12&amp;quot;
&amp;apos;09-12&amp;apos;.padStart(10, &amp;apos;YYYY-MM-DD&amp;apos;) // &amp;quot;YYYY-09-12&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u6A21_u677F_u5B57_u7B26_u4E32&quot;&gt;&lt;a href=&quot;#u6A21_u677F_u5B57_u7B26_u4E32&quot; class=&quot;headerlink&quot; title=&quot;模板字符串&quot;&gt;&lt;/a&gt;模板字符串&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;传统的JavaScript语言，输出模板通常是这样写的。

$(&amp;apos;#result&amp;apos;).append(
  &amp;apos;There are &amp;lt;b&amp;gt;&amp;apos; + basket.count + &amp;apos;&amp;lt;/b&amp;gt; &amp;apos; +
  &amp;apos;items in your basket, &amp;apos; +
  &amp;apos;&amp;lt;em&amp;gt;&amp;apos; + basket.onSale +
  &amp;apos;&amp;lt;/em&amp;gt; are on sale!&amp;apos;
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;apos;#result&amp;apos;).append(`
  There are &amp;lt;b&amp;gt;${basket.count}&amp;lt;/b&amp;gt; items
   in your basket, &amp;lt;em&amp;gt;${basket.onSale}&amp;lt;/em&amp;gt;
  are on sale!
`);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 普通字符串
`In JavaScript &amp;apos;\n&amp;apos; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
var name = &amp;quot;Bob&amp;quot;, time = &amp;quot;today&amp;quot;;
`Hello ${name}, how are you ${time}?`
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。&lt;/p&gt;
&lt;p&gt;号，则前面要用反斜杠转义。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var greeting = `\`Yo\` World!`;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;apos;#list&amp;apos;).html(`
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
`);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。&lt;/ul&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$(&amp;apos;#list&amp;apos;).html(`
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;first&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;second&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
`.trim());
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模板字符串中嵌入变量，需要将变量名写在${}之中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function authorize(user, action) {
  if (!user.hasPrivilege(action)) {
    throw new Error(
      // 传统写法为
      // &amp;apos;User &amp;apos;
      // + user.name
      // + &amp;apos; is not authorized to do &amp;apos;
      // + action
      // + &amp;apos;.&amp;apos;
      `User ${user.name} is not authorized to do ${action}.`);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var x = 1;
var y = 2;

`${x} + ${y} = ${x + y}`
// &amp;quot;1 + 2 = 3&amp;quot;

`${x} + ${y * 2} = ${x + y * 2}`
// &amp;quot;1 + 4 = 5&amp;quot;

var obj = {x: 1, y: 2};
`${obj.x + obj.y}`
// 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模板字符串之中还能调用函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fn() {
  return &amp;quot;Hello World&amp;quot;;
}

`foo ${fn()} bar`
// foo Hello World bar
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。&lt;/p&gt;
&lt;p&gt;如果模板字符串中的变量没有声明，将报错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 变量place没有声明
var msg = `Hello, ${place}`;
// 报错
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`Hello ${&amp;apos;World&amp;apos;}`
// &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;模板字符串甚至还能嵌套。&lt;br&gt;    const tmpl = addrs =&amp;gt; &lt;code&gt;&amp;lt;table&amp;gt;
      ${addrs.map(addr =&amp;gt;&lt;/code&gt;&lt;br&gt;        &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;        &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;&lt;br&gt;      &lt;code&gt;).join(&amp;#39;&amp;#39;)}
      &amp;lt;/table&amp;gt;&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const data = [
    { first: &amp;apos;&amp;lt;Jane&amp;gt;&amp;apos;, last: &amp;apos;Bond&amp;apos; },
    { first: &amp;apos;Lars&amp;apos;, last: &amp;apos;&amp;lt;Croft&amp;gt;&amp;apos; },
];

console.log(tmpl(data));
// &amp;lt;table&amp;gt;
//
//   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;Jane&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
//   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Bond&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
//
//   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Lars&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
//   &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;Croft&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
//
// &amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 写法一
let str = &amp;apos;return &amp;apos; + &amp;apos;`Hello ${name}!`&amp;apos;;
let func = new Function(&amp;apos;name&amp;apos;, str);
func(&amp;apos;Jack&amp;apos;) // &amp;quot;Hello Jack!&amp;quot;

// 写法二
let str = &amp;apos;(name) =&amp;gt; `Hello ${name}!`&amp;apos;;
let func = eval.call(null, str);
func(&amp;apos;Jack&amp;apos;) // &amp;quot;Hello Jack!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;手打,学习,来自阮一峰的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;br&gt;想要学 node.js 与最新的框架 ,最好先学ES6&lt;/p&gt;
&lt;h2 id=&quot;u5B57_u
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="ECMA6" scheme="http://HeartWalker.cc/tags/ECMA6/"/>
    
  </entry>
  
  <entry>
    <title>ECMA6入门学习之let与const</title>
    <link href="http://HeartWalker.cc/2016/07/17/ECMA6%E5%85%A5%E9%97%A8%E4%B9%8Blet%E4%B8%8Econst/"/>
    <id>http://HeartWalker.cc/2016/07/17/ECMA6入门之let与const/</id>
    <published>2016-07-17T11:28:47.000Z</published>
    <updated>2016-07-17T12:16:37.395Z</updated>
    
    <content type="html">&lt;p&gt;手打,学习,来自阮一峰的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;br&gt;想要学 node.js 与最新的框架 ,最好先学ES6&lt;/p&gt;
&lt;h2 id=&quot;let_u547D_u4EE4&quot;&gt;&lt;a href=&quot;#let_u547D_u4EE4&quot; class=&quot;headerlink&quot; title=&quot;let命令&quot;&gt;&lt;/a&gt;let命令&lt;/h2&gt;&lt;h3 id=&quot;u57FA_u672C_u7528_u6CD5&quot;&gt;&lt;a href=&quot;#u57FA_u672C_u7528_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;&lt;p&gt;ES6新增了let命令, 用来声明变量. 它的用法类似var,但是所声明的变量, 只在let命令行所在的代码块内有效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    let a = 10;
    var b = 1;
};
a //Uncaught ReferenceError: a is not defined
b //1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们通常使用的for循环计数器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(let i = 0; i &amp;lt; 10; i++){};
console.log(i);  //Uncaught ReferenceError: i is not defined(…  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码计数器i, 只在for循环体内有效&lt;/p&gt;
&lt;p&gt;下面的代码如果使用var,最后输出的是10&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = [];
for(var i= 0; i &amp;lt; 10; i++){
    a[ i ] = function(){
        console.log(i);
    };
}    
a[6](); //10
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 变量i是var声明的, 在全局范围内都有小. 所以每一次循环, 新的i值都会覆盖旧值, 导致最后输出的是最后一轮的i的值.&lt;/p&gt;
&lt;p&gt;如果使用let, 声明的变量仅在块级作用域内有效, 最后输出的是6&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = [];
for(let i = 0; i &amp;lt; 10;i++){
    a[i] = function(){
        console.log(i);
    };
}    
a[6](); //6
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中,变量i是let声明的,当前的i只在本轮循环内有效, 所以每一次循环的i其实都是一个新的变量,所以最后输出的是6&lt;/p&gt;
&lt;h3 id=&quot;u4E0D_u5B58_u5728_u53D8_u91CF_u63D0_u5347&quot;&gt;&lt;a href=&quot;#u4E0D_u5B58_u5728_u53D8_u91CF_u63D0_u5347&quot; class=&quot;headerlink&quot; title=&quot;不存在变量提升&quot;&gt;&lt;/a&gt;不存在变量提升&lt;/h3&gt;&lt;p&gt;let不像var那样会发生”变量提升”现象. 所以,变量一定要在在声明后使用,否则报错.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(foo); //undefiend
console.log(bar); // Uncaught ReferenceError: bar is not defined
var foo = 2;
let bar = 2;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 变量foo用var命令声明,会发生变量提升,既脚本开始运行时,变量foo已经存在了,但没有值,所以会输出undefined. 变量bar用let命令声明, 不会发生变量提升. 这表示在声明它之前, 变量bar是不存在的,这时如果用到它,就会抛出一个错误.&lt;/p&gt;
&lt;h3 id=&quot;u6682_u65F6_u6027_u6B7B_u533A&quot;&gt;&lt;a href=&quot;#u6682_u65F6_u6027_u6B7B_u533A&quot; class=&quot;headerlink&quot; title=&quot;暂时性死区&quot;&gt;&lt;/a&gt;暂时性死区&lt;/h3&gt;&lt;p&gt;只要块级作用域内存在let命令, 他所声明的变量就”绑定”(binding)这个区域,不再受外部的影响.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var tmp = 123;
if(true){
    tmp = &amp;apos;abc&amp;apos;; //ReferenceError
    let tmp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中,存在全局变量tmp, 但是块级作用于能let又声明了一个局部变量tmp, 导致了后者绑定在这个块级作用域, 所以在let声明变量前,对tmp赋值会报错.&lt;/p&gt;
&lt;p&gt;ES6明确规定,如果区块中存在let和const命令, 这个区块对这些命令声明的变量, 从一开始就形成了封闭作用域. 凡是在声明之前就使用这些变量, 就会报错.&lt;/p&gt;
&lt;p&gt;总之, 在代码块内, 使用let命令声明变量之前, 该变量都是不可用的. 这在于发生, 称为”暂时性死区”(temporal dead zone, 简称 TDZ)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(true){
    //TDZ开始
    tem = &amp;apos;abc&amp;apos;; //ReferenceError
    console.log(tmp); //ReferenceError

    let tmp; //TDZ结束
    console.log(tmp); //undefiend

    tmp = 123;
    console.log(tmp); //123
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 在let命令声明变量tmp之前, 都属于tmp的”死区”&lt;/p&gt;
&lt;p&gt;“暂时性死区”也意味着typeof不再是一个百分百安全的操作;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typeof x; //ReferenceError
let x;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 变量x使用let命令声明,所以在声明之前,都属于x的”死区”,只要用到该变量就会报错. 因此, typeof 运行时就会抛出一个 ReferenceError.&lt;br&gt;作为比较, 如果一个变量根本没有被声明, 使用typeof反而不会报错.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typeof undeclared_variable;//&amp;quot;undefiend&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, undeclared_variable是一个不存在的变量名, 结果返回”undefined”. 所以, 在没有let之前, typeof运算符是百分之百安全的, 永远不会报错. 现在这一点不成立了. 这样的设计是为了让大家养成良好的变成习惯, 变量一定要在声明后使用, 否则就报错.&lt;/p&gt;
&lt;p&gt;有些”死区”比较隐蔽, 不太容易发现.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function bar(x = 2, y = x){
    return [x,y];
}
bar(); //报错
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 调用bar函数之所以报错(某些实现可能不报错), 是因为参数x默认值等于另一个参数y,而此时y还没有声明, 属于”死区”. 如果y的默认值是x,就不会报错,因为此时x已经声明了.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function bar(x = 2, y = x){
    return [x,y];
}
bar(); //[2,2]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ES6规定暂时性死区和不存在变量提升,主要是为了减少运行时错误,防止在变量声明前就使用这个变量,从而导致意料之外的行为. 这样的错误在ES5是很常见的, 现在有了这种规定, 避免此类错误就很容易了. &lt;/p&gt;
&lt;p&gt;总之, 暂时性死区的本质就是, 只要一进入当前作用域, 所要使用的变量就已经存在了, 但是不可获取, 只要等到声明变量的那一行代码出现, 才可以获取和使用该变量.    &lt;/p&gt;
&lt;h3 id=&quot;let_u4E0D_u5141_u8BB8_u91CD_u590D_u58F0_u660E&quot;&gt;&lt;a href=&quot;#let_u4E0D_u5141_u8BB8_u91CD_u590D_u58F0_u660E&quot; class=&quot;headerlink&quot; title=&quot;let不允许重复声明&quot;&gt;&lt;/a&gt;let不允许重复声明&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;//报错
function test(){
    let a = 10;
    var a = 1;
}
//报错
function test(){
    let a = 10;
    let a = 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此, 不能在函数内部重新声明参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function func(arg){
    let arg;//报错
} 
function func(arg){
    {
        let arg; //不报错
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u5757_u7EA7_u4F5C_u7528_u57DF&quot;&gt;&lt;a href=&quot;#u5757_u7EA7_u4F5C_u7528_u57DF&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h3&gt;&lt;p&gt;为什么需要块级作用域?&lt;br&gt;ES5只有全局作用域和函数作用域, 没有块级作用域,这带来很多不合理的场景.&lt;br&gt;第一种场景, 内层变量可能会覆盖外层变量.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var tmp = new Date();
function f(){
   console.log(tmp);
   if(false){
       var tmp = &amp;quot;hellow world&amp;quot;;
   }
}   
f();//undefiend
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 函数f执行后,输出结果为undefined, 原因在于变量提升, 导致内层的tmp变量覆盖了外层的tmp变量&lt;/p&gt;
&lt;p&gt;第二种场景, 用来计数的循环变量泄露为全局变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var s = &amp;apos;hello&amp;apos;;
for(var i = 0; i&amp;lt;s.length; i++){
    console.log(s[i]);
}
console.log(i); //5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 变量i只是用来控制循环, 但是循环结束后, 它并没有消失, 泄露成了全局变量    &lt;/p&gt;
&lt;h3 id=&quot;ES6_u7684_u5757_u7EA7_u4F5C_u7528_u57DF&quot;&gt;&lt;a href=&quot;#ES6_u7684_u5757_u7EA7_u4F5C_u7528_u57DF&quot; class=&quot;headerlink&quot; title=&quot;ES6的块级作用域&quot;&gt;&lt;/a&gt;ES6的块级作用域&lt;/h3&gt;&lt;p&gt;let实际上为JavaScript新增了块级作用域&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f1(){
    let n = 5;
    if(true){
        let n = 10;
    }
    console.log(n); 
}
f1(); //5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的函数有两个代码块, 都声明了变量n, 运行后输出5. 这表示外城代码块不收内层代码块的影响. 如果使用var变量定义n, 最后的输出值就是10&lt;/p&gt;
&lt;p&gt;ES6允许块级作用域的任意嵌套.&lt;br&gt;    { { { { {let insane = ‘Hello World’} } } } };&lt;br&gt;上面代码使用了一个五层的块级作用域. 外层作用域无法读取内层作用域的变量.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ { { {
    {let insane = &amp;apos;Hello Word&amp;apos;};
    console.log(insane); //报错
    } } } } ;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内层作用域可以定义外层作用域的同名变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ { { {
    let insane = &amp;apos;Hello World&amp;apos;;
    {let insane = &amp;apos;Hello World&amp;apos;}
    } } } } 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;块级作用域的出现, 实际上( ⊙ o ⊙ )使得获得广泛易用的立即执行匿名函数(IIFE)不在必要了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//IIFE写法
(function(){
    var tmp = 111;
})();
//块级作用域写法
{
    let tmp = 111;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;const_u547D_u4EE4&quot;&gt;&lt;a href=&quot;#const_u547D_u4EE4&quot; class=&quot;headerlink&quot; title=&quot;const命令&quot;&gt;&lt;/a&gt;const命令&lt;/h2&gt;&lt;p&gt;const 声明一个只读的常量. 一旦声明, 常量的值就不能改变&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const PI = 3.1415;
PI //3.1415
PI = 3;//TypeError: Assignment to constant variable
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码表明改变常量的值会报错&lt;/p&gt;
&lt;p&gt;construction声明的变量不得改变值, 这意味着, const一旦声明变量,就必须立即初始化,不能留到以后赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const foo;
//SystaxErrow:Missing initializer in const declaration    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码表示, 对于const 来说, 只要声明不赋值, 就会报错&lt;/p&gt;
&lt;p&gt;const的作用域与let命令相同; 只在声明所在的块级作用域内有效&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(true){
    const MAX = 5;
}
MAX //Uncaught ReferenceError: MAX is not defined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;const 命令声明的常量也是不提升的, 同样存在暂时性死区, 只能在声明的位置后面使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(true){
    console.log(MAX); //ReferenceError
    const MAX = 5;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码在常量MAX声明之前就调用, 结果报错&lt;/p&gt;
&lt;p&gt;const声明的常量, 也与let一样不可重复声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var message = &amp;quot;Hellow&amp;quot;;
let age = 25;
//以下两行都会报错
const message = &amp;quot;Goodbye&amp;quot;;
const age = 30;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于符合类型的变量, 变量名不指向数据, 而是指向数据所在的地址. const命令指示保证变量名指向的地址不变, 并不保证该地址的数据不变, 所以讲一个对象声明为常量必须非常小心&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const foo = {};
foo.prop = 123;
foo.prop //123
foo = {};//TypeError:&amp;quot;foo&amp;quot; is read-only
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 常量foo储存的是一个地址,这个地址指向一个对象. 不可变的指示真个地址, 既不能把foo指向另一个地址, 但对象本身是可变的, 所以依然可以为其添加新属性. &lt;/p&gt;
&lt;p&gt;下面是另一个例子.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const a = [];
a.push(&amp;apos;Hellow&amp;apos;);
a.length = 0;
a = [&amp;apos;Dave&amp;apos;]; //报错
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中,常量a是一个数组, 这个数组本身是可写的, 但是如果将另一个数组赋值给a, 就会报错.&lt;/p&gt;
&lt;p&gt;如果真的想将对象冻结, 应该使用Object.freeze方法.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const foo = Object.freeze({});
//常规模式时,下面一行不起作用;
//严格模式时,该行会报错
foo.prop = 123;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 常量foo指向一个冻结的对象, 所以添加新属性时不起作用, 严格模式时还会报错.&lt;/p&gt;
&lt;p&gt;除了将对象本身冻结, 对象的属性也应该冻结. 下面是一个将对象彻底冻结的函数.(既深冻结)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var constantize  = (obj) =&amp;gt;{
    Obj.freeze(obj);
    Object.keys(obj).forEach(key, value) =&amp;gt;{
        if( typeof obj[key] === &amp;apos;obj&amp;apos;){
            constantize(obj[key]);
        }
    };
}   ;   
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ES5只有两种声明变量的方法: var命令和function命令. ES6除了添加let和const命令, 另外还有两种声明变量的方法import和class命令. 所以ES6一共有6中声明变量的方法.&lt;/p&gt;
&lt;h2 id=&quot;u5168_u5C40_u5BF9_u8C61_u7684_u5C5E_u6027&quot;&gt;&lt;a href=&quot;#u5168_u5C40_u5BF9_u8C61_u7684_u5C5E_u6027&quot; class=&quot;headerlink&quot; title=&quot;全局对象的属性&quot;&gt;&lt;/a&gt;全局对象的属性&lt;/h2&gt;&lt;p&gt;全局对象是最顶层的对象, 在浏览器环境指的是window对象,在Node.js指的是global对象. ES5中,全局对象的属性和全局变量是等价的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;window.a = 1;
a //1
a = 2;
window.a //2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 全局对象的属性赋值与全局变量的赋值,是同一件事. (对Node来说,这一条支队REPL环境中使用, 模块环境之中, 全局变量必须显示的声明成global对象的属性).&lt;/p&gt;
&lt;p&gt;未声明的全局变量, 自动成为全局属性的window的属性, 这被认为是JavaScript语言最大的设计败笔之一. 这样的设计带来了两个很大的问题, 首先是没法再编译时就报出变量未声明的错误, 只有运行时才能知道, 其次程序员很容易不知不觉地就创建全局变量(比如打字出错). 另一方面, 从语义上讲, 语言的顶层对象时一个有实体含义的对象, 也是不适合的.&lt;/p&gt;
&lt;p&gt;ES6为了改变着一点, 一方面规定, 为了保持兼容性, var命令和function命令声明的全局变量, 依旧是全局对象的属性; 另一方面规定, let命令, const命令, class命令声明的全局变量, 不属于全局对象的属性. 也就是说, 从ES6开始, 全局变量将逐步与全局对象属性脱钩.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 1;
//如果在Node的REPL环境, 可以写成global.a
//或者采用通用的方法, 写成this.a
window.a //1
let b = 1;
window.b //undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 全局变量 a 由 var命令声明, 所以它是全局对象的属性; 全局变量b由let命令声明, 所以它不是全局对象的属性, 反回 undefiend&lt;br&gt;(待验证:  在node模块中, var 全局定义变量只会在本模块生效, 若直接 赋值 会在各个引用的模块中生效)&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;手打,学习,来自阮一峰的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;br&gt;想要学 node.js 与最新的框架 ,最好先学ES6&lt;/p&gt;
&lt;h2 id=&quot;let_u54
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="ECMA6" scheme="http://HeartWalker.cc/tags/ECMA6/"/>
    
  </entry>
  
  <entry>
    <title>ECMA6入门学习之解构赋值</title>
    <link href="http://HeartWalker.cc/2016/07/17/ECMA6%E5%85%A5%E9%97%A8%E4%B9%8B%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://HeartWalker.cc/2016/07/17/ECMA6入门之解构赋值/</id>
    <published>2016-07-17T11:28:47.000Z</published>
    <updated>2016-07-17T12:22:33.649Z</updated>
    
    <content type="html">&lt;p&gt;手打,学习,来自阮一峰的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;br&gt;想要学 node.js 与最新的框架 ,最好先学ES6&lt;/p&gt;
&lt;h3 id=&quot;u6570_u7EC4_u7684_u89E3_u6784_u8D4B_u503C&quot;&gt;&lt;a href=&quot;#u6570_u7EC4_u7684_u89E3_u6784_u8D4B_u503C&quot; class=&quot;headerlink&quot; title=&quot;数组的解构赋值&quot;&gt;&lt;/a&gt;数组的解构赋值&lt;/h3&gt;&lt;p&gt;基本用法&lt;/p&gt;
&lt;p&gt;ES6允许按一定的模式, 从数组和对象中提取值, 对变量进行赋值, 这被称为解构(DEstructuring).&lt;br&gt;以前, 为变量赋值, 只能直接指定值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a = 1;
var b = 2;
var c = 3;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ES6允许写成下面这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var [a, b, c] = [1, 2, 3];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码表示, 可以从数组中提取值, 按照对应位置, 对变量赋值.&lt;/p&gt;
&lt;p&gt;本质上, 这种写法属于”模式匹配”, 只要等号两边的模式相同, 左边的变量就会被赋予对应的值. 下面是一些使用嵌套数组进行解构的例子.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let [foo,[[bar],baz]] = [1,[[2],3]];
foo //1
bar //2
baz //3

let [ , , third] = [&amp;apos;foo&amp;apos;, &amp;apos;bar&amp;apos;, &amp;apos;baz&amp;apos;];
third //&amp;apos;baz&amp;apos;

let [x, , y] = [1, 2, 3];
x //1
y //3

let [head, ...tail] = [1, 2, 3, 4];
head //1
tail //[2, 3, 4]

let [x , , ...z] = [&amp;apos;a&amp;apos;];
x //&amp;apos;a&amp;apos;
y //undefiend
z //[]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果结构不成功, 变量的值就等于undefined&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var [foo] = [];
var [bar, foo] = [1]; //bar 1,foo undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上两种情况都属于解构不成功, foo的值都会等于undefined.        &lt;/p&gt;
&lt;p&gt;另一种情况是不完全结构, 即等号左边的模式, 只匹配一部分的等号右边的数组. 这种情况下, 解构依然可以成功.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let [x, y] = [1, 2, 3];
x //1
y //2

let [a, [b], d] = [1, [2, 3],4];
a //1
b //2
d //4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面连个例子, 都属于不完全结构, 但是都可以成功.&lt;/p&gt;
&lt;p&gt;如果等号的右边不是数组(或者严格的说, 不是可遍历的结构, 参见&amp;lt;&amp;lt; Iterator &amp;gt;&amp;gt; 一章), 那么将会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefiend;
let [foo] = null;
let [foo] = {};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的表达式都会报错, 因为等号右边的值, 要么转为对象以后不具备Iterator接口(前五个表达式), 要么本身就不具备Iterator接口(最后一个表达式).&lt;/p&gt;
&lt;p&gt;解构赋值不仅使用于var命令, 也适用于let和const命令.&lt;/p&gt;
&lt;p&gt;对于Set(ES6新特性)结构, 也可以使用数组的结构赋值   &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let [x, y, z] = new Set([&amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, &amp;apos;c&amp;apos;]); 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事实上, 只要某种数据结构具有Iterator接口, 都可以采用数组形式的结构赋值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function* fibs() {
    var a = 0;
    var b = 1;
    while(true){
        yield a;
        [a, b] = [b, a + b];
    }
}        
var [first, second, third, fourth, fifth, sixth] = fibs();
sixth //5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, fibs是一个Generator函数, 原生具有Iterator接口. 结构赋值会依次从这个接口获取值&lt;/p&gt;
&lt;h3 id=&quot;u9ED8_u8BA4_u503C&quot;&gt;&lt;a href=&quot;#u9ED8_u8BA4_u503C&quot; class=&quot;headerlink&quot; title=&quot;默认值&quot;&gt;&lt;/a&gt;默认值&lt;/h3&gt;&lt;p&gt;结构赋值允许指定默认值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var [foo = true] = [];
foo //true
[x, y = &amp;apos;b&amp;apos;] = [&amp;apos;a&amp;apos;]; //x = &amp;apos;a&amp;apos;, y = &amp;apos;b&amp;apos;
[x, y = &amp;apos;b&amp;apos;] = [&amp;apos;a&amp;apos;, undefiend]; //x=&amp;apos;a&amp;apos;,y=&amp;apos;b&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 如过一个数组成员是null, 默认值就不会生效, 因为null不严格等于undefined.&lt;/p&gt;
&lt;p&gt;如果默认值是一个表达式, 那么这个表达式是惰性求值的, 即只有在用到的时候, 才会求值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f(){
    console.log(&amp;apos;aaa&amp;apos;;)
}
let [x = f()] = [1];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 因为x能取到值, 所以函数f根本不会执行. 上面的代码其实等价于下面的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let x;
if([1][0] === undefined){
    x = f();
} else {
    x = [1][0];
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认值可以引用结构赋值的其他变量, 但该变量必须已经声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let [ x = 1, y = x] = []; //x=1;y=1;  
let [ x= 1, y = x] = [2]; //x=2;y=2
let [x = 1, y = x] = [1, 2]; //x=1; y=2;
let [x = y, y = 1] = []; //报错
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面最后一个表达式之所以会报错, 是因为x用到默认值y时,y还没有声明  &lt;/p&gt;
&lt;h3 id=&quot;u5BF9_u8C61_u7684_u7ED3_u6784_u8D4B_u503C&quot;&gt;&lt;a href=&quot;#u5BF9_u8C61_u7684_u7ED3_u6784_u8D4B_u503C&quot; class=&quot;headerlink&quot; title=&quot;对象的结构赋值&quot;&gt;&lt;/a&gt;对象的结构赋值&lt;/h3&gt;&lt;p&gt;结构赋值不仅可以用于数组, 还可以用于对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var {foo, bar} = { foo:&amp;apos;aaa&amp;apos;, bar: &amp;apos;bbb&amp;apos;};
foo //&amp;quot;aaa&amp;quot;
bar //&amp;quot;bbb&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对象的结构与数组有一个重要的不同. 数组的元素是按次序排列的, 变量的取值由它的位置决定; 而对象的属性没有次序, 变量必需要与属性同名, 才能取到正确的值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var {baz} = {foo: &amp;apos;aaa&amp;apos;,bar :&amp;apos;bbb&amp;apos;};
baz // undefiend        
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上边这个例子变量baz没有对应的同名属性, 导致取不到值, 最后等于undefined&lt;/p&gt;
&lt;p&gt;如果变量名与属性名不一致, 必须写成下面这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var { foo: baz} = { foo: &amp;quot;aaa&amp;quot; ,bar: &amp;quot;bbb&amp;quot;};
baz // &amp;quot;aaa&amp;quot;

let obj = { first : &amp;apos;hello&amp;apos;, last: &amp;apos;world&amp;apos;};
let {first: f, last: l} = obj;
f //&amp;quot;hellow&amp;quot;
l //&amp;quot;world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这实际上说明, 对象的结构赋值是下面形式的简写(参见&amp;lt;&amp;lt; 对象的扩展 &amp;gt;&amp;gt;一章)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var { foo : foo, bar: bar} = { foo : &amp;quot;aaa&amp;quot;, bar : &amp;quot;bbb&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也就是说, 对象的解构赋值的内部机制, 是先找到同名属性, 然后再赋值给对应的变量. 真正被赋值的是后者, 而不是前者.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var { foo: baz } = { foo: &amp;quot;aaa&amp;quot;, bar: &amp;quot;bbb&amp;quot; };
baz // &amp;quot;aaa&amp;quot;
foo // error: foo is not defined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，真正被赋值的是变量baz，而不是模式foo。&lt;/p&gt;
&lt;p&gt;注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let foo;
let {foo} = {foo: 1}; // SyntaxError: Duplicate     declaration &amp;quot;foo&amp;quot;

let baz;
let {bar: baz} = {bar: 1}; // SyntaxError:  Duplicate declaration &amp;quot;baz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let foo;
({foo} = {foo: 1}); // 成功

let baz;
({bar: baz} = {bar: 1}); // 成功
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和数组一样，解构也可以用于嵌套结构的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var obj = {
  p: [
    &amp;quot;Hello&amp;quot;,
    { y: &amp;quot;World&amp;quot; }
  ]
};

var { p: [x, { y }] } = obj;
x // &amp;quot;Hello&amp;quot;
y // &amp;quot;World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，这时p是模式，不是变量，因此不会被赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var node = {
  loc: {
    start: {
      line: 1,
      column: 5
    }
  }
};

var { loc: { start: { line }} } = node;
line // 1
loc  // error: loc is undefined
start // error: start is undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，只有line是变量，loc和start都是模式，不会被赋值。&lt;/p&gt;
&lt;p&gt;下面是嵌套赋值的例子。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let obj = {};
let arr = [];

({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar:  true });

obj // {prop:123}
arr // [true]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;hw注: 最好还是不要使用嵌套&lt;/p&gt;
&lt;p&gt;对象的解构也可以指定默认值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var { message: msg = &amp;quot;Something went wrong&amp;quot; } = {};
msg // &amp;quot;Something went wrong&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认值生效的条件是，对象的属性值严格等于undefined。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。&lt;/p&gt;
&lt;p&gt;如果解构失败，变量的值等于undefined。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var {foo} = {bar: &amp;apos;baz&amp;apos;};
foo // undefined
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。&lt;/p&gt;
&lt;p&gt;上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var _tmp = {baz: &amp;apos;baz&amp;apos;};
_tmp.foo.bar // 报错
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果要将一个已经声明的变量用于解构赋值，必须非常小心。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 错误的写法

var x;
{x} = {x: 1};
// SyntaxError: syntax error
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 正确的写法
({x} = {x: 1});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。&lt;/p&gt;
&lt;p&gt;解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;({} = [true, false]);
({} = &amp;apos;abc&amp;apos;);
({} = []);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的表达式虽然毫无意义，但是语法是合法的，可以执行。&lt;/p&gt;
&lt;p&gt;对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let { log, sin, cos } = Math;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。&lt;/p&gt;
&lt;h3 id=&quot;u5B57_u7B26_u4E32_u7684_u89E3_u6784_u8D4B_u503C&quot;&gt;&lt;a href=&quot;#u5B57_u7B26_u4E32_u7684_u89E3_u6784_u8D4B_u503C&quot; class=&quot;headerlink&quot; title=&quot;字符串的解构赋值&quot;&gt;&lt;/a&gt;字符串的解构赋值&lt;/h3&gt;&lt;p&gt;字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const [a, b, c, d, e] = &amp;apos;hello&amp;apos;;
a // &amp;quot;h&amp;quot;
b // &amp;quot;e&amp;quot;
c // &amp;quot;l&amp;quot;
d // &amp;quot;l&amp;quot;
e // &amp;quot;o&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let {length : len} = &amp;apos;hello&amp;apos;;
len // 5
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u6570_u503C_u548C_u5E03_u5C14_u503C_u7684_u7ED3_u6784_u8D4B_u503C&quot;&gt;&lt;a href=&quot;#u6570_u503C_u548C_u5E03_u5C14_u503C_u7684_u7ED3_u6784_u8D4B_u503C&quot; class=&quot;headerlink&quot; title=&quot;数值和布尔值的结构赋值&quot;&gt;&lt;/a&gt;数值和布尔值的结构赋值&lt;/h3&gt;&lt;p&gt;解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。&lt;/p&gt;
&lt;p&gt;解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let { prop: x } = undefined; // TypeError
let { prop: y } = null; // TypeError
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u51FD_u6570_u53C2_u6570_u7684_u7ED3_u6784_u8D4B_u503C&quot;&gt;&lt;a href=&quot;#u51FD_u6570_u53C2_u6570_u7684_u7ED3_u6784_u8D4B_u503C&quot; class=&quot;headerlink&quot; title=&quot;函数参数的结构赋值&quot;&gt;&lt;/a&gt;函数参数的结构赋值&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;function add([x, y]){
    return x + y;
}

add([1, 2]); //3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 函数 add 的参数表面上是一个数组, 但在传入参数的那一刻, 数组参数就被解构成变量 x 和 y. 对于函数内部的代码来说, 他们能感受到的参数就是 x 和 y. &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[[1,2], [3, 4]].map(([a, b]) =&amp;gt; a + b);
//[3,7]    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数参数的解构也可以使用默认值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function move({x = 0, y +})    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数参数的解构也可以使用默认值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function move({x =0 , y =0} = {}){
    return [x , y];
}    
move({x: 3, y:8}) ;//[3, 8]
move({x:3}); //[3, 0]
move({}); //[0, 0]
move(); //[0,0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码中, 函数move的参数是一个对象, 通过对这个对象进行解构, 得到变量 x和y的值,如果解构失败, x和y等于默认值&lt;br&gt;注意, 线面的写法会得到不一样的结果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。&lt;/p&gt;
&lt;p&gt;undefined就会触发函数参数的默认值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[1, undefined, 3].map((x = &amp;apos;yes&amp;apos;) =&amp;gt; x);
// [ 1, &amp;apos;yes&amp;apos;, 3 ]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u7528_u9014&quot;&gt;&lt;a href=&quot;#u7528_u9014&quot; class=&quot;headerlink&quot; title=&quot;用途&quot;&gt;&lt;/a&gt;用途&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;交换变量的值&lt;/p&gt;
&lt;p&gt; [x, y] = [y, x];&lt;br&gt;上面的代码交换x和y的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;从函数返回多个值&lt;br&gt;函数只能返回一个值, 如果要返回多个值, 只要将他们房子啊数组或对象中返回. 有了解构赋值, 取出这些值就非常方便.&lt;/p&gt;
&lt;p&gt; //返回一个数组&lt;br&gt; function example(){&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return [1, 2, 3];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; var [a, b, c] = example();&lt;/p&gt;
&lt;p&gt; //返回一个对象&lt;/p&gt;
&lt;p&gt; function exa(){&lt;br&gt; return {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;foo:1,
bar:2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; };&lt;br&gt; }&lt;br&gt; var {foo, bar } = example();&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数的参数定义&lt;br&gt;结构赋值可以方便地将一组参数与变量名对应起来.&lt;/p&gt;
&lt;p&gt; //参数是一组有次序的值&lt;br&gt; function f([x, y, z]) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return [x, y, z];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; f([1, 2, 3]);&lt;br&gt; //参数是一组无次序的值&lt;br&gt;   function f({x, y, z}) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return [x, y, z];
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt; f({z:3, y:2,x:1});&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提取JSON数据&lt;br&gt;结构赋值对提取JSON对象中的数据,尤其有用.&lt;/p&gt;
&lt;p&gt; var jsonData = {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;id: 42,
status: &amp;quot;OK&amp;quot;,
data: [867 ,5309]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }   ;&lt;br&gt; let {id, status, data:number} = jsonData;&lt;br&gt; console.log(id, status, number);&lt;br&gt; //42, “OK”, [857, 5309]&lt;br&gt;上面的代码可以快速提取JSON数据的值        &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数参数的默认值&lt;/p&gt;
&lt;p&gt; jQuery.ajax = function (url, {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async = true,
beforeSend = function(){},
cache  =  true,
//...more config
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }) {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//... do stuff
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; }&lt;br&gt;指定参数的默认值, 就避免了在函数内部再写 var foo = config.foo || “default foo”; 这样的语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;遍历Map结构&lt;br&gt;任何部署了Iterator接口的对象, 都可以用for …of循环遍历. Map结构原生支持Iterator接口, 配合变量的解构赋值, 获取键名和键值就非常简单.&lt;/p&gt;
&lt;p&gt; var map = new Map();&lt;br&gt; map.set(‘first’,’hello’);&lt;br&gt; map.set(‘second’,’world’);&lt;br&gt; for( let [key, value] of map){&lt;br&gt;  console.log(key+ “ is “+ value);&lt;br&gt; }&lt;br&gt; // first is hello&lt;br&gt; // second is world&lt;/p&gt;
&lt;p&gt; 如果只想获取键名，或者只想获取键值，可以写成下面这样。&lt;/p&gt;
&lt;p&gt; // 获取键名&lt;br&gt; for (let [key] of map) {&lt;br&gt;   // …&lt;br&gt; }&lt;/p&gt;
&lt;p&gt; // 获取键值&lt;br&gt; for (let [,value] of map) {&lt;br&gt;   // …&lt;br&gt; }&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;输入模块的指定方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;加载模块时, 往往需要指定输入那些方法. 解构赋值使得语句非常清晰&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const {SouceMapConsumer, SourceNode} = require(&amp;quot;source-map&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;手打,学习,来自阮一峰的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客&lt;/a&gt;&lt;br&gt;想要学 node.js 与最新的框架 ,最好先学ES6&lt;/p&gt;
&lt;h3 id=&quot;u6570_u
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="ECMA6" scheme="http://HeartWalker.cc/tags/ECMA6/"/>
    
  </entry>
  
  <entry>
    <title>jsonp的原理与简单实现</title>
    <link href="http://HeartWalker.cc/2016/07/06/jsonp%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://HeartWalker.cc/2016/07/06/jsonp的原理与简单实现/</id>
    <published>2016-07-06T13:31:21.000Z</published>
    <updated>2016-07-07T15:18:00.610Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u539F_u7406&quot;&gt;&lt;a href=&quot;#u539F_u7406&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。&lt;/p&gt;
&lt;p&gt;其本质是利用了&amp;lt; script src=”” &amp;gt;&amp;lt;/ script &amp;gt;标签具有可跨域的特性，由服务端返回一个预先定义好的Javascript函数的调用，并且将服务器数据以该函数参数的形式传递过来，此方法需要前后端配合完成。&lt;br&gt;它只能以GET方式请求&lt;br&gt;一般将传递的 key 命名为 callback&lt;/p&gt;
&lt;h3 id=&quot;php_u670D_u52A1_u5668_u793A_u4F8B&quot;&gt;&lt;a href=&quot;#php_u670D_u52A1_u5668_u793A_u4F8B&quot; class=&quot;headerlink&quot; title=&quot;php服务器示例&quot;&gt;&lt;/a&gt;php服务器示例&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;?php&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    header(&lt;span class=&quot;string&quot;&gt;&#39;Content-Type: text/javascript; charset=utf-8&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 假设从数据库里取数据了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;$arr&lt;/span&gt; = array(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;name&quot;&lt;/span&gt;=&amp;gt;&lt;span class=&quot;string&quot;&gt;&quot;js&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;&quot;age&quot;&lt;/span&gt;=&amp;gt;&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 编码处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;$json&lt;/span&gt; = json_encode(&lt;span class=&quot;variable&quot;&gt;$arr&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //获取客户端的callback函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;variable&quot;&gt;$callback&lt;/span&gt; = &lt;span class=&quot;variable&quot;&gt;$_GET&lt;/span&gt;[&lt;span class=&quot;string&quot;&gt;&#39;callback&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //给接收到的函数传输入据&lt;span class=&quot;variable&quot;&gt;$json&lt;/span&gt;作为参数, 输出到html页面运行该函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;$callback&lt;/span&gt; . &lt;span class=&quot;string&quot;&gt;&#39;(&#39;&lt;/span&gt; . &lt;span class=&quot;variable&quot;&gt;$json&lt;/span&gt; . &lt;span class=&quot;string&quot;&gt;&#39;)&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;?&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;u5BA2_u6237_u7AEF_u793A_u4F8B&quot;&gt;&lt;a href=&quot;#u5BA2_u6237_u7AEF_u793A_u4F8B&quot; class=&quot;headerlink&quot; title=&quot;客户端示例&quot;&gt;&lt;/a&gt;客户端示例&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;html lang=&lt;span class=&quot;string&quot;&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;meta charset=&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var jsonp = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         var count = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (url, callback) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;. 创建一个script标签&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var scriptElem = document.createElement(&lt;span class=&quot;string&quot;&gt;&#39;script&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;. 把地址传进去&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var callbackName = &lt;span class=&quot;string&quot;&gt;&quot;__callback__&quot;&lt;/span&gt; + count++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var jsonpUrl = url + &lt;span class=&quot;string&quot;&gt;&quot;?callback=&quot;&lt;/span&gt; + callbackName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            scriptElem.src = jsonpUrl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;. 创建一个fn函数，用于接收返回的数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            window[callbackName] = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //把数据传给想要用的人&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                callback(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //把我们创建的script标签删掉&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                window.document.body.removeChild(scriptElem);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;.把标签放到body，把请求发出去&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            window.document.body.appendChild(scriptElem);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    jsonp(&lt;span class=&quot;string&quot;&gt;&#39;./js.php&#39;&lt;/span&gt;,&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; cs(data)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        data = JSON.stringify(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.log(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;控制台输出:{“name”:”js”,”age”:20}&lt;br&gt;注: 请在php服务器下运行&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u539F_u7406&quot;&gt;&lt;a href=&quot;#u539F_u7406&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h3&gt;&lt;p&gt;由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="跨域" scheme="http://HeartWalker.cc/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式之观察者模式</title>
    <link href="http://HeartWalker.cc/2016/07/03/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://HeartWalker.cc/2016/07/03/JS设计模式之观察者模式/</id>
    <published>2016-07-03T14:42:29.000Z</published>
    <updated>2016-07-17T11:47:20.167Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u6982_u5FF5&quot;&gt;&lt;a href=&quot;#u6982_u5FF5&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;它定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都将得到通知. 在JavaScript开发中, 我们一般用事件模型来代替传统的观察者模式.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u6982_u5FF5&quot;&gt;&lt;a href=&quot;#u6982_u5FF5&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;它定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都将得到通知. 在J
    
    </summary>
    
      <category term="设计模式" scheme="http://HeartWalker.cc/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://HeartWalker.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>J设计模式之迭代器模式</title>
    <link href="http://HeartWalker.cc/2016/07/03/J%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://HeartWalker.cc/2016/07/03/J设计模式之迭代器模式/</id>
    <published>2016-07-03T09:50:30.000Z</published>
    <updated>2016-07-03T13:25:22.223Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u6982_u5FF5&quot;&gt;&lt;a href=&quot;#u6982_u5FF5&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素,而又不需要暴露该对象的内部表示.迭代器模式可以吧迭代的过程从业务逻辑中分离出来,在使用迭代器模式之后,即使不关心对象的内部构造,也可以按顺序访问其中的每个元素.&lt;br&gt;大部分语言都有内部迭代器的实现,ECMAScript5也增加了数组的迭代方法 forEach &lt;/p&gt;
&lt;h3 id=&quot;u5185_u90E8_u8FED_u4EE3_u5668&quot;&gt;&lt;a href=&quot;#u5185_u90E8_u8FED_u4EE3_u5668&quot; class=&quot;headerlink&quot; title=&quot;内部迭代器&quot;&gt;&lt;/a&gt;内部迭代器&lt;/h3&gt;&lt;p&gt;内部迭代器是函数的内部已经定义好了迭代器规则,它完全接手整个迭代过程,外部只需要一次初始调用&lt;br&gt;下边实现一个自己的内部迭代器&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var each = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(arr, fn)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //这里只考虑arr是数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var i, l = arr.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; l; i++ ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //把下标和元素当做参数传递给fn函数,并提供跳出的方法,如果fn的返回值为&lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;则提前终止循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( fn.call( arr[ i ], i, arr[ i ] ) === &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;u5916_u90E8_u8FED_u4EE3_u5668&quot;&gt;&lt;a href=&quot;#u5916_u90E8_u8FED_u4EE3_u5668&quot; class=&quot;headerlink&quot; title=&quot;外部迭代器&quot;&gt;&lt;/a&gt;外部迭代器&lt;/h3&gt;&lt;p&gt;外部迭代器必须显示地请求迭代下一个元素,我们可以手工控制迭代的过程或顺序,相比内部迭代器有更强的灵活性&lt;br&gt;下边实现一个自己的外部迭代器&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var Iterator  = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(obj)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var current = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var next = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        current += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var isDone = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; current &amp;gt;= obj.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var getCurrItem = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; obj[ current ];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        next:next,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        isDone: isDone,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        getSingle: getCurrItem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u6982_u5FF5&quot;&gt;&lt;a href=&quot;#u6982_u5FF5&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素,而又不需要暴露该对象的内部表示.迭代器模式可
    
    </summary>
    
      <category term="设计模式" scheme="http://HeartWalker.cc/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://HeartWalker.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>line-height之height</title>
    <link href="http://HeartWalker.cc/2016/07/02/line-height%E4%B9%8Bheight/"/>
    <id>http://HeartWalker.cc/2016/07/02/line-height之height/</id>
    <published>2016-07-02T06:45:36.000Z</published>
    <updated>2016-07-02T07:09:31.989Z</updated>
    
    <content type="html">&lt;p&gt;本文并非介绍line-height的四条线,也不说它是如何继承的 &lt;/p&gt;
&lt;h3 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h3&gt;&lt;p&gt;在 PC 端,为了实现文字居中, 我们这样写 CSS&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;html lang=&lt;span class=&quot;string&quot;&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;meta charset=&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        * &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            margin:&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            padding: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .box &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            width: &lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            height: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            line-height: &lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            border:&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;px solid orange;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            text-align: center;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            color:black;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/style&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;div class=&lt;span class=&quot;string&quot;&gt;&quot;box&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        测试&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;好,很好,非常好,简简单单就实现了文字居中,可喜可贺 咦! 我为啥要写border属性呢?无所谓啦,这种事随它去吧&lt;br&gt;真的是无所谓么&lt;br&gt;有时在移动端我们会加上这个属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-sizing:border-box;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来没有什么不一样啊!&lt;br&gt;让我修改一下border&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;border:50px solid black;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这他么什么鬼,画风完全不对好吧&lt;br&gt;这时候只需要将更改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;line-height: 100px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;文字就再次居中了&lt;/p&gt;
&lt;p&gt;让我恢复到原来的属性然后加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;padding:50px 0;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;花还香香的&lt;br&gt;再来一条&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;box-sizing:border-box;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;…&lt;br&gt;这时候也需要更改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;line-height:98px;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;哦!!!&lt;br&gt;不管你们懂不懂,反正我是懂了&lt;/p&gt;
&lt;p&gt;我们都知道当 height 与 line-height 的高度相等的时候文字会垂直居中 ,这个 height 指的得是盒模型的 content 部分,不包括 padding 与 border&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;本文并非介绍line-height的四条线,也不说它是如何继承的 &lt;/p&gt;
&lt;h3 id=&quot;Demo&quot;&gt;&lt;a href=&quot;#Demo&quot; class=&quot;headerlink&quot; title=&quot;Demo&quot;&gt;&lt;/a&gt;Demo&lt;/h3&gt;&lt;p&gt;在 PC 端,为了实现文字居中, 我们这样
    
    </summary>
    
      <category term="css" scheme="http://HeartWalker.cc/categories/css/"/>
    
    
      <category term="css布局" scheme="http://HeartWalker.cc/tags/css%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法学习</title>
    <link href="http://HeartWalker.cc/2016/07/02/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <id>http://HeartWalker.cc/2016/07/02/算法学习/</id>
    <published>2016-07-02T06:31:52.000Z</published>
    <updated>2016-07-02T06:43:07.118Z</updated>
    
    <content type="html">&lt;p&gt;JS常见算法学习收集整理&lt;/p&gt;
&lt;h2 id=&quot;u6392_u5E8F&quot;&gt;&lt;a href=&quot;#u6392_u5E8F&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h2&gt;&lt;h3 id=&quot;u6392_u5E8F_u6982_u5FF5&quot;&gt;&lt;a href=&quot;#u6392_u5E8F_u6982_u5FF5&quot; class=&quot;headerlink&quot; title=&quot;排序概念&quot;&gt;&lt;/a&gt;排序概念&lt;/h3&gt;&lt;p&gt;排序就是要整理文件中的记录，使之按关键字递增(或递减)次序排列起来。其确切定义如下：输入：n 个记录 R1，R2，…，Rn，其相应的关键字分别为 K1，K2，…，Kn。输出：Ril，Ri2，…，Rin，使得 Ki1≤Ki2≤…≤Kin。(或 Ki1≥Ki2≥…≥Kin)。&lt;/p&gt;
&lt;p&gt;排序算法的依据–关键字，关键字可以是数字类型，也可以是字符类型。&lt;br&gt;排序算法的稳定性&lt;/p&gt;
&lt;p&gt;当待排序记录的关键字均不相同时，排序结果是惟一的，否则排序结果不唯一。在待排序的文件中，若存在多个关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序保持不变，该排序方法是稳定的；若具有相同关键字的记录之间的相对次序发生变化，则称这种排序方法是不稳定的。&lt;br&gt;排序算法的空间复杂度&lt;/p&gt;
&lt;p&gt;若排序算法所需的辅助空间并不依赖于问题的规模n，即辅助空间是O(1)，则称之为就地排序(In-PlaceSou)。 非就地排序一般要求的辅助空间为O(n)。&lt;/p&gt;
&lt;h3 id=&quot;u76F4_u63A5_u63D2_u5165_u6392_u5E8F&quot;&gt;&lt;a href=&quot;#u76F4_u63A5_u63D2_u5165_u6392_u5E8F&quot; class=&quot;headerlink&quot; title=&quot;直接插入排序&quot;&gt;&lt;/a&gt;直接插入排序&lt;/h3&gt;&lt;p&gt;把待排序的纪录按其关键码值的大小逐个插入到一个已经排好序的有序序列中，直到所有的纪录插入完为止，得到一个新的有序序列。&lt;/p&gt;
&lt;p&gt;设无序数组为a[0…n-1]。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.初始时，a[0]自成1个有序区，无序区为a[1..n-1]。

2.令i=1,将a[i]插入当前的有序区a[0…i-1]中形成a[0…i]的有序区间。

3.i++并重复第二步直到i==n-1，排序完成。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一趟直接插入排序方法&lt;/p&gt;
&lt;p&gt;具体做法：&lt;/p&gt;
&lt;p&gt;将待插入记录 a[i]的关键字从右向左依次与有序区中记录 aj的关键字进行比较：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.若 a[j]的关键字大于 a[i]的关键字，则将 a[j]后移一个位置；

2.若 a[j]的关键字小于或等于 a[i]的关键字，则查找过程结束，j+1 即为 a[i]的插入位置。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关键字比a[i]的关键字大的记录均已后移，所以 j+1 的位置已经腾空，只要将 a[i] 直接插入此位置即可完成一趟直接插入排序。&lt;/p&gt;
&lt;p&gt;例如待排序数组a[0]=8,a[1]=5,a[2]=10,a[3]=12,a[4]=7,a[5]=6&lt;/p&gt;
&lt;p&gt;第一趟：a[0]=8，有序,a[1…5]无序。&lt;/p&gt;
&lt;p&gt;第二趟：temp=5，a[1]=5 &amp;lt; a[0]=8, 8往后移一位，a[1]=8,a[0]=5,a[0…1]有序,a[2…5]无序。&lt;/p&gt;
&lt;p&gt;第三、四趟：a[2]=10 &amp;gt; a[1]=8,a[3]=12 &amp;gt; a[2]=10，有序无须移动，a[4…5]无序。&lt;/p&gt;
&lt;p&gt;第五趟：temp=7，a[4]=7 &amp;lt; a[3]=12,12往后移一位，a[4]=12，依次类推…直到a[0]=5 &amp;lt; temp，即a[1]=7。&lt;/p&gt;
&lt;p&gt;第六趟类比第五趟，可以得到6插入位置为a[1]=6。排序完成。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var insertSort = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(array)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,temp,len = array.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(; i&amp;lt;len;++i)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp = array[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(--j &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(array[j] &amp;gt; temp)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                array[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = array[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        array[j+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]=temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; array;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;直接插入排序算法时间复杂度：O(n^2)；空间复杂度：O(1)。直接插入排序是稳定的排序方法。&lt;/p&gt;
&lt;h3 id=&quot;u5192_u6CE1_u6392_u5E8F&quot;&gt;&lt;a href=&quot;#u5192_u6CE1_u6392_u5E8F&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h3&gt;&lt;p&gt;两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。按照从小到大或者从大到小的顺序进行交换,这样一趟过去后,最大或最小的数字被交换到了最后一位。&lt;/p&gt;
&lt;p&gt;冒泡排序算法的运作过程：（从小到大排序）&lt;/p&gt;
&lt;p&gt;设数组a[0..n-1]长度为n,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1．比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。

2．这样对数组的第0个数据到n-1个数据进行一次遍历后，最大的一个数据就“沉”到数组第n-1个位置。

3．n=n-1，如果n不为0就重复前面二步，否则排序完成。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例子为从小到大排序,原始待排序数组| 7 | 2 | 4 | 1 | 5 |&lt;/p&gt;
&lt;p&gt;第一趟排序(外循环)&lt;/p&gt;
&lt;p&gt;第一次两两比较7 &amp;gt; 2交换(内循环)&lt;/p&gt;
&lt;p&gt;交换前状态| 7 | 2 | 4 | 1 | 5 |&lt;/p&gt;
&lt;p&gt;交换后状态| 2 | 7 | 4 | 1 | 5 |&lt;/p&gt;
&lt;p&gt;第二次两两比较,7 &amp;gt; 4交换&lt;/p&gt;
&lt;p&gt;交换前状态| 2 | 7 | 4 | 1 | 5 |&lt;/p&gt;
&lt;p&gt;交换后状态| 2 | 4 | 7 | 1 | 5 |&lt;/p&gt;
&lt;p&gt;第三次两两比较,7 &amp;gt; 1交换&lt;/p&gt;
&lt;p&gt;交换前状态| 2 | 4 | 7 | 1 | 5 |&lt;/p&gt;
&lt;p&gt;交换后状态| 2 | 4 | 1 | 7 | 5 |&lt;/p&gt;
&lt;p&gt;第四次两两比较,7 &amp;gt; 5交换&lt;/p&gt;
&lt;p&gt;交换前状态| 2 | 4 | 1 | 7 | 5 |&lt;/p&gt;
&lt;p&gt;交换后状态| 2 | 4 | 1 | 5 | 7 |&lt;/p&gt;
&lt;p&gt;第二趟排序(外循环)&lt;/p&gt;
&lt;p&gt;第一次两两比较2 &amp;lt; 4不交换&lt;/p&gt;
&lt;p&gt;交换前状态| 2 | 4 | 1 | 5 | 7 |&lt;/p&gt;
&lt;p&gt;交换后状态| 2 | 4 | 1 | 5 | 7 |&lt;/p&gt;
&lt;p&gt;第二次两两比较,4 &amp;gt; 1交换&lt;/p&gt;
&lt;p&gt;交换前状态| 2 | 4 | 1 | 5 | 7 |&lt;/p&gt;
&lt;p&gt;交换后状态| 2 | 1 | 4 | 5 | 7 |&lt;/p&gt;
&lt;p&gt;第三趟排序(外循环)&lt;/p&gt;
&lt;p&gt;第一次两两比较2 &amp;gt; 1交换&lt;/p&gt;
&lt;p&gt;交换后状态| 2 | 1 | 4 | 5 | 7 |&lt;/p&gt;
&lt;p&gt;交换后状态| 1 | 2 | 4 | 5 | 7 |&lt;/p&gt;
&lt;p&gt;第二次两两比较,2 &amp;lt; 4不交换&lt;/p&gt;
&lt;p&gt;交换后状态| 1 | 2 | 4 | 5 | 7 |&lt;/p&gt;
&lt;p&gt;交换后状态| 1 | 2 | 4 | 5 | 7 |&lt;/p&gt;
&lt;p&gt;排序完毕,输出最终结果1 2 4 5 7&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var bubbleSort = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(array)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                len = array.length,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                j,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;i &amp;lt; len;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; len; j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(array[i] &amp;lt; array[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            temp = array[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            array[j] = array[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            array[i] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; array;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//或者这样更好理解&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; bubbleSort(arr) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var i = arr.length, j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (i &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; j &amp;lt; i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (arr[j] &amp;gt; arr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        temp = arr[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        arr[j] = arr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        arr[j + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                i--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;冒泡排序时间复杂度，最好情况：数组已有序O(n)；最坏情况:数组反序O(n^2)，平均时间复杂度：O(n^2)。空间复杂度，冒泡排序是原地排序，空间复杂度为O(1)。冒泡排序算法是稳定的排序算法。&lt;/p&gt;
&lt;h3 id=&quot;u76F4_u63A5_u9009_u62E9_u6392_u5E8F&quot;&gt;&lt;a href=&quot;#u76F4_u63A5_u9009_u62E9_u6392_u5E8F&quot; class=&quot;headerlink&quot; title=&quot;直接选择排序&quot;&gt;&lt;/a&gt;直接选择排序&lt;/h3&gt;&lt;p&gt;无序数组a[0…n-1]，第一次从a[0]~a[n-1]中选取最小值，与a[0]交换，第二次从a[1]~a[n-1]中选取最小值，与a[1]交换，….，第i次从a[i-1]~a[n-1]中选取最小值，与a[i-1]交换，…..，第n-1次从a[n-2]~a[n-1]中选取最小值，与a[n-2]交换，总共通过n-1次，得到一个按关键字从小到大排列的有序序列·&lt;/p&gt;
&lt;p&gt;直接选择排序算法过程如下:&lt;/p&gt;
&lt;p&gt;给定n=7，数组a中的7个元素为[8,3,2,1,7,4,6]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;初始状态 [ 8 3 2 1 7 4 6]

第1次，数组a[0..6]中最小的数为a[3]=1，交换a[3]&amp;lt;-&amp;gt;a[0]，交换结果[ 1 3 2 8 7 4 6]

第2次，数组a[1..6]中最小的数为a[2]=2，交换a[2]&amp;lt;-&amp;gt;a[1]，交换结果[ 1 2 3 8 7 4 6]

第3次，数组a[2..6]中最小的数为a[2]=3，交换a[2]&amp;lt;-&amp;gt;a[2]，交换结果[ 1 2 3 8 7 4 6]

第4次，数组a[3..6]中最小的数为a[5]=4，交换a[5]&amp;lt;-&amp;gt;a[3]，交换结果[ 1 2 3 4 6 8 7]

第5次，数组a[4..6]中最小的数为a[4]=6，交换a[4]&amp;lt;-&amp;gt;a[4]，交换结果[ 1 2 3 4 6 8 7]

第6次，数组a[5..6]中最小的数为a[6]=7，交换a[6]&amp;lt;-&amp;gt;a[5]，交换结果[ 1 2 3 4 6 7 8]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;排序完成。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var selectSort = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(array)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        min,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        len = array.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(;i &amp;lt; len - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        min = i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(j=i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j&amp;lt; len;j++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(array[min] &amp;gt; array[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                min = j;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        temp = array[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        array[i] = array[min];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        array[min] = temp; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; array;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在直接选择排序中，共需要进行n-1次选择和交换，每次选择需要进行 n-i 次比较 (1&amp;lt;=i&amp;lt;=n-1),而每次交换最多需要3次移动，因此，总的比较次数C=(n*n - n)/2，时间复杂度O(n^2)。直接选择排序为原地排序，空间复杂度O(1)。直接选择排序不是稳定的排序算法。&lt;/p&gt;
&lt;h3 id=&quot;u5E0C_u5C14_u6392_u5E8F&quot;&gt;&lt;a href=&quot;#u5E0C_u5C14_u6392_u5E8F&quot; class=&quot;headerlink&quot; title=&quot;希尔排序&quot;&gt;&lt;/a&gt;希尔排序&lt;/h3&gt;&lt;p&gt;把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。&lt;/p&gt;
&lt;p&gt;希尔排序算法过程：&lt;/p&gt;
&lt;p&gt;先取一个正整数gap&lt;/p&gt;
&lt;p&gt;例如数组a[49, 38, 65, 97, 26, 13, 27, 49, 55, 4]&lt;/p&gt;
&lt;p&gt;第1次 步长 gap = 10 / 2 = 5&lt;/p&gt;
&lt;p&gt;分成了五组(49, 13) (38, 27) (65, 49) (97, 55) (26, 4)，&lt;/p&gt;
&lt;p&gt;每组排序后变成了(13, 49) (27, 38) (49, 65) (55, 97) (4, 26)。&lt;/p&gt;
&lt;p&gt;第1次排序结果：13 27 49 55 4 49 38 65 97 26&lt;/p&gt;
&lt;p&gt;第2次 步长 gap = 5 / 2 = 2&lt;/p&gt;
&lt;p&gt;分成了2组(13,49,4,38,97) (27,55,49,65,26)&lt;/p&gt;
&lt;p&gt;每组排序后变成了(4,13,38,49,97) (26,27,49,55,65)&lt;/p&gt;
&lt;p&gt;第2次排序结果：4 26 13 27 38 49 49 55 97 65&lt;/p&gt;
&lt;p&gt;第3次 步长 gap = 2 / 2 = 1&lt;/p&gt;
&lt;p&gt;分为一组，直接插入排序后，数组有序。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var shellSort = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(array)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     var len = array.length, gap = parseInt(len/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         i, j, tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(gap &amp;gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         //循环使i=gap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i=gap; i&amp;lt;len; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             //给临时值tmp赋值为array[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             tmp = array[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             //j是i减去增量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             j = i - gap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(j&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; tmp &amp;lt; array[j])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     array[i] = array[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                     j = j - gap;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             array[j+gap] = tmp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         //改变增量gap 控制循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         gap = parseInt(gap/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; array;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//或者这样&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var shellSort = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(array)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var len=array.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(var gap=Math.floor(len/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;); gap&amp;gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; gap=Math.floor(gap/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(var i=gap; i&amp;lt;len; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(var j=i-gap; j&amp;gt;=&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&amp;amp;&amp;amp;array[j]&amp;gt;array[gap+j]; j-=gap)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var temp = array[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                array[j] = array[gap+j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                array[gap+j] = temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;希尔排序的时间复杂度与增量序列的选取有关，例如希尔增量时间复杂度为O(n²)，而Hibbard增量的希尔排序的时间复杂度为O(n^(3/2))，希尔排序时间复杂度的下界是n*log2n，希尔排序时间复杂度O(Nlog2N)，空间复杂度O(1)。希尔排序不是稳定排序算法。&lt;/p&gt;
&lt;h3 id=&quot;u5FEB_u901F_u6392_u5E8F&quot;&gt;&lt;a href=&quot;#u5FEB_u901F_u6392_u5E8F&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h3&gt;&lt;p&gt;首先从数组a中选取一个基准点（通常我们取中间项作为基准点），然后遍历数组，把小于基准点的项放到基准点左边集合，把大于基准点的项放到基准点右边集合。再对左边和右边两个集合重复前面的操作，直到每个子集就剩下一个元素。其实就是一个递归的思想。&lt;/p&gt;
&lt;p&gt;依旧拿数组a=[12,3,43,11,56,90,7,66,82]举例，我们先选取一个基准点pivot=a[Math.floor(a.length/2)]，即a[4]值为56，然后便利数组中的剩余项，把小于56的数组项放在左边的数组left中，把大于等于56的数组项放在右边的数组right中，第一轮操作结束后left=[12,3,43,11,7]，right=[90,66,82]，然后再对left和right重复以上的操作，直到left和right仅剩一项或为空时结束。最后返回left+pivot+right。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; quickSort(arr)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var len=arr.length;//获取arr的长度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(len&amp;lt;=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&amp;#123;//如果arr的长度小于等于&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;则直接返回arr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; arr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var pIndex=Math.floor(len/&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);//获取基准点的索引下标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var pivot=arr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var left=[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var right=[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(var i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i&amp;lt;arr.length; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(arr[i]&amp;lt;pivot)&amp;#123;//如果小于基准点就放到数组l中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                left.push(arr[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;//如果大于等于基准点就放到右边数组中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                right.push(arr[i]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; quickSort(left).concat(pivot,quickSort(right));//递归不断重复整个过程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;快速排序算法平均时间复杂度O(nlgn)，最坏O(n^2)。快速排序需要栈空间来实现递归，如果数组按局等方式被分割时，则最大的递归深度为 log n，需要的栈空间为 O(log n)。最坏的情况下在递归的每一级上，数组分割成长度为0的左子数组和长度为 n - 1 的右数组。这种情况下，递归的深度就成为 n，需要的栈空间为 O(n)。快速排序不是稳定排序算法。&lt;/p&gt;
&lt;h2 id=&quot;u611F_u6168&quot;&gt;&lt;a href=&quot;#u611F_u6168&quot; class=&quot;headerlink&quot; title=&quot;感慨&quot;&gt;&lt;/a&gt;感慨&lt;/h2&gt;&lt;p&gt;算法这种东西不经常用,学起来也比较伤脑,而且学了忘学了又忘,果然对我这个特别平凡的人来说算法不太适合么&lt;br&gt;好烦 不搞了&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;JS常见算法学习收集整理&lt;/p&gt;
&lt;h2 id=&quot;u6392_u5E8F&quot;&gt;&lt;a href=&quot;#u6392_u5E8F&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h2&gt;&lt;h3 id=&quot;u6392_u5E8F_u6982_u5FF5&quot;&gt;&lt;a
    
    </summary>
    
      <category term="东成西就" scheme="http://HeartWalker.cc/categories/%E4%B8%9C%E6%88%90%E8%A5%BF%E5%B0%B1/"/>
    
    
      <category term="算法" scheme="http://HeartWalker.cc/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>在webstorm中使用sass</title>
    <link href="http://HeartWalker.cc/2016/06/29/%E5%9C%A8webstorm%E4%B8%AD%E4%BD%BF%E7%94%A8sass/"/>
    <id>http://HeartWalker.cc/2016/06/29/在webstorm中使用sass/</id>
    <published>2016-06-28T22:55:07.000Z</published>
    <updated>2016-06-28T23:17:59.987Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u6539_u53D8&quot;&gt;&lt;a href=&quot;#u6539_u53D8&quot; class=&quot;headerlink&quot; title=&quot;改变&quot;&gt;&lt;/a&gt;改变&lt;/h3&gt;&lt;p&gt;最近新入了一家公司&lt;br&gt;以前都是这样写css&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nav ul &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  margin: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  padding: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  list-style: none;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nav li &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  display: inline-block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nav a &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  display: block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  padding: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;px &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;px;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  text-decoration: none;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;多好啊,简单易懂,清晰明了&lt;br&gt;现在要求这样&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nav ul &amp;#123; margin: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; padding: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; list-style: none; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nav li &amp;#123; display: inline-block; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nav a &amp;#123; display: block; padding: &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;px &lt;span class=&quot;number&quot;&gt;12&lt;/span&gt;px; text-decoration: none; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;虽然最后都要压缩,但没办法那就只能这样写了,可是以前使用emmet语法,会自动换行,这可怎么办,幸亏我大部分项目都是使用强大的webstorm写的,经过不断尝试终于在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;File--&amp;gt;Settings--&amp;gt;Editor--&amp;gt;Code Style--&amp;gt;CSS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;目录下的选项卡 Other 下找到了 Keep single-line blocks ,只要把此项勾选从此智能提示不换行, 顿时喜笑颜开&lt;/p&gt;
&lt;p&gt;但是还不能满足,我要用 Less, 用Less啊,自动生成的 CSS 样式还是要换行,这可怎么办,网上各种查资料,最后发现没有办法啊没有办法,这他么是在逗我呢. &lt;/p&gt;
&lt;p&gt;我明明记得能控制输出 CSS 的样式,难道我记错了么?这不可能!哦,真的是我记错了,支持控制输出CSS样式的是 Sass.&lt;br&gt;其实用Sass一开始我是拒绝的,虽然说比Less强大,但是我们用得着那些强大的功能么,我平时只要只用嵌套好吧,而且要装 ruby, 好烦,我只是个小前端,到底要做到哪一步啊,我记得学习 ionic 的时候还装了 Python 还有 Java Android 环境什么的,心好塞…&lt;br&gt;就在这时我发现了一个好物&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/node-sass&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;node-sass&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;webstorm 是支持 node-sass,额至少 webstorm11 是支持的&lt;/p&gt;
&lt;p&gt;首先你需要全局安装&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install node-sass -g
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后在&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;File--&amp;gt;Settings--&amp;gt;Tools--&amp;gt;File Watchers
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;目录下点击右上角的 + ,选择 SCSS 就可以了,然后配置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Program: C:\Users\Administrator\AppData\Roaming\npm\node-sass.cmd(输入你的node-sass.cmd的路径)
Arguments: $FileName$ $FileNameWithoutExtension$.css
Working directory: $FileDir$
Output paths to refresh: $FileNameWithoutExtension$.css
&amp;apos;Create output from stdout&amp;apos; should be off(不要勾选该选项)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后找到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\Administrator\AppData\Roaming\npm\node_modules\node-sass\bin\node-sass (你自己的全局npm模块下)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开在 default下(第100行)有个 output-style ,将它的值改为 compact 就可以实现我需要的输出效果了.&lt;br&gt;如果你想了解更多可以访问&lt;br&gt;&lt;a href=&quot;http://stackoverflow.com/questions/23732228/sass-filewatcher-for-webstorm&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;来自stackOverflow&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当然如果你不用 webstorm 并且有需要的话 gulp 是一个非常好的选择&lt;/p&gt;
&lt;p&gt;果然身为程序员有问题还是要上 stack Overflow&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u6539_u53D8&quot;&gt;&lt;a href=&quot;#u6539_u53D8&quot; class=&quot;headerlink&quot; title=&quot;改变&quot;&gt;&lt;/a&gt;改变&lt;/h3&gt;&lt;p&gt;最近新入了一家公司&lt;br&gt;以前都是这样写css&lt;br&gt;&lt;figure class=&quot;highlight 
    
    </summary>
    
      <category term="东成西就" scheme="http://HeartWalker.cc/categories/%E4%B8%9C%E6%88%90%E8%A5%BF%E5%B0%B1/"/>
    
    
      <category term="webstorm" scheme="http://HeartWalker.cc/tags/webstorm/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式之代理模式</title>
    <link href="http://HeartWalker.cc/2016/06/26/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://HeartWalker.cc/2016/06/26/JS设计模式之代理模式/</id>
    <published>2016-06-26T14:04:26.000Z</published>
    <updated>2016-07-17T11:47:16.974Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u6982_u5FF5&quot;&gt;&lt;a href=&quot;#u6982_u5FF5&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;代理模式是为一个对象提供提供代用品或占位符,以便控制对他的访问&lt;br&gt;代理模式的关键是,当客户不方便直接访问一个对象或者不满足需要的时候,提供一个替身对象来控制对这个对象的访问,客户实际访问的是替身对象&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u6982_u5FF5&quot;&gt;&lt;a href=&quot;#u6982_u5FF5&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;代理模式是为一个对象提供提供代用品或占位符,以便控制对他的访问&lt;br&gt;代理模式的关键是,当客户不方便直接
    
    </summary>
    
      <category term="设计模式" scheme="http://HeartWalker.cc/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://HeartWalker.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JS设计模式之策略模式</title>
    <link href="http://HeartWalker.cc/2016/06/22/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://HeartWalker.cc/2016/06/22/JS设计模式之策略模式/</id>
    <published>2016-06-21T23:38:36.000Z</published>
    <updated>2016-06-26T13:12:27.250Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u5B9A_u4E49&quot;&gt;&lt;a href=&quot;#u5B9A_u4E49&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;定义一系列的算法,把他们一个个封装起来,并且使它们可以互相替换&lt;br&gt;当然策略模式并不仅仅可以封装算法,也可以封装一系列的’业务规则’或者说是’应用逻辑’,只要这些业务规则指向的目标一致,并且可以被替换使用,我们就可以用策略模式来封装它们&lt;br&gt;策略模式主要是实现了松散耦合&lt;/p&gt;
&lt;h3 id=&quot;u4E00_u4E2A_u4F7F_u7528_u7B56_u7565_u6A21_u5F0F_u6587_u672C_u8F93_u5165_u6846_u6821_u9A8C_u89C4_u5219_u6837_u4F8B_u4EE3_u7801&quot;&gt;&lt;a href=&quot;#u4E00_u4E2A_u4F7F_u7528_u7B56_u7565_u6A21_u5F0F_u6587_u672C_u8F93_u5165_u6846_u6821_u9A8C_u89C4_u5219_u6837_u4F8B_u4EE3_u7801&quot; class=&quot;headerlink&quot; title=&quot;一个使用策略模式文本输入框校验规则样例代码&quot;&gt;&lt;/a&gt;一个使用策略模式文本输入框校验规则样例代码&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;!-- 一个使用策略模式文本输入框校验规则样例代码 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;form action=&lt;span class=&quot;string&quot;&gt;&quot;javascript:;&quot;&lt;/span&gt; id=&lt;span class=&quot;string&quot;&gt;&quot;registerForm&quot;&lt;/span&gt; method=&lt;span class=&quot;string&quot;&gt;&quot;post&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      请输入用户名: &amp;lt;input &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;text&quot;&lt;/span&gt; name=&lt;span class=&quot;string&quot;&gt;&quot;userName&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      请输入密码: &amp;lt;input &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;password&quot;&lt;/span&gt; name=&lt;span class=&quot;string&quot;&gt;&quot;password&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      请输入手机号码: &amp;lt;input &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;phoneName&quot;&lt;/span&gt; name=&lt;span class=&quot;string&quot;&gt;&quot;phoneName&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;button&amp;gt;提交&amp;lt;/button&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/form&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 定义策略&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var strategies = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //判断是否为空&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            isNonEmpty: &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(value, errorMsg)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(value === &lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; errorMsg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //判断最小长度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            minLength: &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(value, length, errorMsg)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (value.length &amp;lt; length) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; errorMsg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //判断手机号是否合法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            isMoblile: &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(value, errorMsg)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!/(^&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;|&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;|&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;-&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;]&amp;#123;&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;&amp;#125;$)/.test(value))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; errorMsg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //定义验证器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var Validator = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            this.cache = [];//校验规则缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Validator.prototype.add = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(dom, rules)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var self = this;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(var i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,rule;rule = rules[ i++ ];)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                (&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(rule)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    //规则参数数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    var strategyAry = rule.strategy.split(&lt;span class=&quot;string&quot;&gt;&#39;:&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    //错误信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    var errorMsg = rule.errorMsg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    self.cache.push(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        //删除参数数组的要校验的规则并用strategy接收&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        var strategy = strategyAry.shift();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        //接收dom的value值作为第一个参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        strategyAry.unshift(dom.value);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        strategyAry.push(errorMsg);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; strategies[ strategy ].apply(dom,strategyAry);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;)(rule);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //循环验证每条规则&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Validator.prototype.start = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(var i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,validatorFunc;validatorFunc = this.cache[i++];)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var errorMsg = validatorFunc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(errorMsg)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; errorMsg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // 页面调用代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var registerForm = document.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;registerForm&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var validataFunc = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var validator = new Validator();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //为每一个输入框分别添加规则&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            validator.add(registerForm.userName,[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                strategy:&lt;span class=&quot;string&quot;&gt;&#39;isNonEmpty&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                errorMsg:&lt;span class=&quot;string&quot;&gt;&#39;用户名不能为空&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                strategy: &lt;span class=&quot;string&quot;&gt;&#39;minLength:6&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                errorMsg: &lt;span class=&quot;string&quot;&gt;&#39;用户名长度不能小于6位&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            validator.add(registerForm.password,[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                strategy:&lt;span class=&quot;string&quot;&gt;&#39;minLength:6&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                errorMsg:&lt;span class=&quot;string&quot;&gt;&#39;密码长度不能小于6位&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            validator.add(registerForm.phoneName,[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                strategy:&lt;span class=&quot;string&quot;&gt;&#39;isMoblile&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                errorMsg:&lt;span class=&quot;string&quot;&gt;&#39;手机号码格式不正确&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //启动校验程序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var errorMsg = validator.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; errorMsg;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //绑定事件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        registerForm.onsubmit = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var errorMsg = validataFunc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            console.log(&lt;span class=&quot;string&quot;&gt;&#39;test&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(errorMsg)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alert(errorMsg);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u5B9A_u4E49&quot;&gt;&lt;a href=&quot;#u5B9A_u4E49&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;定义一系列的算法,把他们一个个封装起来,并且使它们可以互相替换&lt;br&gt;当然策略模式并不仅仅可以封装算法,
    
    </summary>
    
      <category term="设计模式" scheme="http://HeartWalker.cc/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://HeartWalker.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>前端学习之好书推荐</title>
    <link href="http://HeartWalker.cc/2016/06/22/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%A5%BD%E4%B9%A6%E6%8E%A8%E8%8D%90/"/>
    <id>http://HeartWalker.cc/2016/06/22/前端学习之好书推荐/</id>
    <published>2016-06-21T22:44:02.000Z</published>
    <updated>2016-07-06T13:20:22.055Z</updated>
    
    <content type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; JavaScript Dom 编程艺术 &amp;gt;&amp;gt; 目前(第二版)&lt;br&gt;轻松入门 开始学习javascript&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; JavaScript 高级程序设计 &amp;gt;&amp;gt; 目前(第三版)&lt;br&gt;绝对是学习JavaScript的神书, 全部学完以后带来的是质的飞越&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; 锋利的 jQuery &amp;gt;&amp;gt; 目前(第二版)&lt;br&gt;解决兼容性, 链式编程, 方便的 DOM 操作,完善的Ajax,一切从使用 jQuery开始&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; 高性能网站建设指南 &amp;gt;&amp;gt;&lt;br&gt;一些基本的的性能优化,已经体现在网站的方方面面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; 高性能网站建设进阶指南 &amp;gt;&amp;gt;&lt;br&gt;一些高级技巧,技术性比较高,有一些已经过时,有的没有实际经验也很难理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; 图解HTTP &amp;gt;&amp;gt;&lt;br&gt;HTTP 入门好书 ,轻松入门 ,快速了解 HTTP,书非常迷你,携带方便&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; HTTP权威指南 &amp;gt;&amp;gt;&lt;br&gt;如果想要更深入的学习http 这是一本绝对好书,身边的人都在推荐它,但我还没有看过,作为一个特别平凡的人,精力总是有限的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; JavaScript模式 &amp;gt;&amp;gt;&lt;br&gt;一本讲解 JS 模式的好书,前半部分对 JS 的概念讲解与拓展,后边的将模式的部分还是有些抽象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; JavaScript 设计模式与开发实践 &amp;gt;&amp;gt;&lt;br&gt;国内难的的好书之一, 由浅入深, 案例丰富, 绝对值得一看&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; ECMAScript 6 入门 &amp;gt;&amp;gt;&lt;br&gt;想要学习node么, 想要学习最新的框架么, 那你最好先看一下ES6&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; 深入浅出 nodejs &amp;gt;&amp;gt;&lt;br&gt;书如其名, 深入原理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; JavaScript Dom 编程艺术 &amp;gt;&amp;gt; 目前(第二版)&lt;br&gt;轻松入门 开始学习javascript&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&amp;lt;&amp;lt; JavaScript 高级程序设计 &amp;gt;&amp;gt; 目前(第三版
    
    </summary>
    
      <category term="东成西就" scheme="http://HeartWalker.cc/categories/%E4%B8%9C%E6%88%90%E8%A5%BF%E5%B0%B1/"/>
    
    
  </entry>
  
  <entry>
    <title>JS设计模式之单例模式</title>
    <link href="http://HeartWalker.cc/2016/06/21/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://HeartWalker.cc/2016/06/21/JS设计模式之单例模式/</id>
    <published>2016-06-20T23:28:28.000Z</published>
    <updated>2016-06-22T23:15:26.022Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u5B9A_u4E49&quot;&gt;&lt;a href=&quot;#u5B9A_u4E49&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;保证一个类仅有一个实例, 并提供一个访问它的全局访问点 &lt;/p&gt;
&lt;h3 id=&quot;u4E00_u4E2A_u7B80_u5355_u7684_u5355_u4F8B&quot;&gt;&lt;a href=&quot;#u4E00_u4E2A_u7B80_u5355_u7684_u5355_u4F8B&quot; class=&quot;headerlink&quot; title=&quot;一个简单的单例&quot;&gt;&lt;/a&gt;一个简单的单例&lt;/h3&gt;&lt;p&gt;用一个变量标志当前是否已经为某个类创建过对象, 如果有,则在下一次获取该类的实例时直接返回之前创建的对象&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       var Singleton = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(name)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            this.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            this.instance = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Singleton.prototype.getName = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            alert(this.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Singleton.getInstance = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(name)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!this.instance)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                this.instance = new Singleton(name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; this.instance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var a = Singleton.getInstance(&lt;span class=&quot;string&quot;&gt;&#39;sven1&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var b = Singleton.getInstance(&lt;span class=&quot;string&quot;&gt;&#39;sven2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.log(a === b); //&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;u60F0_u6027_u5355_u4F8B&quot;&gt;&lt;a href=&quot;#u60F0_u6027_u5355_u4F8B&quot; class=&quot;headerlink&quot; title=&quot;惰性单例&quot;&gt;&lt;/a&gt;惰性单例&lt;/h3&gt;&lt;p&gt;惰性单例指的是在需要的时候才创建对象实例. 并且我没可以把单例的逻辑抽象出来, 形成通用的惰性单例&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //抽离出的单例逻辑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var getSingle = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(fn)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       var result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; result || (result = fn.apply(this, arguments));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   //执行的函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var createLoginLayer = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       var div = document.createElement(&lt;span class=&quot;string&quot;&gt;&#39;div&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       div.innerHTML =&lt;span class=&quot;string&quot;&gt;&#39;我是登录框&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       document.body.appendChild(div);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; div;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var createSingleLoginLayer = getSingle(createLoginLayer);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这是一个创建登录框的案例, 我们可以在任何需要的时候调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;createSingleLoginLayer();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;并且如果我们需要创建一个iframe 或其他 DOM 节点只需再写一个 执行的函数 ,并重用getSingle&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u5B9A_u4E49&quot;&gt;&lt;a href=&quot;#u5B9A_u4E49&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;保证一个类仅有一个实例, 并提供一个访问它的全局访问点 &lt;/p&gt;
&lt;h3 id=&quot;u4E00_u4E2A
    
    </summary>
    
      <category term="设计模式" scheme="http://HeartWalker.cc/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://HeartWalker.cc/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>gulp参考</title>
    <link href="http://HeartWalker.cc/2016/06/16/gulp%E5%8F%82%E8%80%83/"/>
    <id>http://HeartWalker.cc/2016/06/16/gulp参考/</id>
    <published>2016-06-15T22:22:10.000Z</published>
    <updated>2016-06-15T22:54:27.482Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;gulp学习与使用参考网址收录&lt;/p&gt;
&lt;h3 id=&quot;gulp&quot;&gt;&lt;a href=&quot;#gulp&quot; class=&quot;headerlink&quot; title=&quot;gulp&quot;&gt;&lt;/a&gt;gulp&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://gulpjs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.gulpjs.com.cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中文网&lt;/a&gt;&lt;br&gt;    &lt;a href=&quot;http://gulpjs.com/plugins/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;插件&lt;/a&gt;&lt;br&gt;    &lt;a href=&quot;https://wizardforcel.gitbooks.io/gulp-doc/content/2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Gitbook&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;gulp_u6838_u5FC3API&quot;&gt;&lt;a href=&quot;#gulp_u6838_u5FC3API&quot; class=&quot;headerlink&quot; title=&quot;gulp核心API&quot;&gt;&lt;/a&gt;gulp核心API&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.ydcss.com/archives/424&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.ydcss.com/archives/424&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.hubwiz.com/class/562089cb1bc20c980538e25b#&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.hubwiz.com/class/562089cb1bc20c980538e25b#&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;u5E38_u7528_u63D2_u4EF6_u6536_u96C6&quot;&gt;&lt;a href=&quot;#u5E38_u7528_u63D2_u4EF6_u6536_u96C6&quot; class=&quot;headerlink&quot; title=&quot;常用插件收集&quot;&gt;&lt;/a&gt;常用插件收集&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://markgoodyear.com/2014/01/getting-started-with-gulp/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://markgoodyear.com/2014/01/getting-started-with-gulp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;删除文件和文件夹&lt;br&gt;&lt;a href=&quot;https://github.com/sindresorhus/del&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;del&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;合并js文件&lt;br&gt;&lt;a href=&quot;https://github.com/contra/gulp-concat&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-concat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;合并css文件&lt;br&gt;&lt;a href=&quot;https://github.com/mariocasciaro/gulp-concat-css&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-concat-css&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重命名文件&lt;br&gt;&lt;a href=&quot;https://github.com/hparra/gulp-rename&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-rename&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;压缩js&lt;br&gt;    &lt;a href=&quot;https://github.com/terinjokes/gulp-uglify&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-uglify&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;压缩css&lt;br&gt;&lt;a href=&quot;https://github.com/ben-eb/gulp-cssnano&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-cssnano&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;压缩页面&lt;br&gt;&lt;a href=&quot;https://github.com/sanfords/gulp-minify-html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-minify-html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;压缩照片&lt;br&gt;   &lt;a href=&quot;https://github.com/sindresorhus/gulp-imagemin&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-imagemin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自动打开浏览器&lt;br&gt;&lt;a href=&quot;https://github.com/stevelacy/gulp-open&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-open&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;依赖自动加载&lt;br&gt;[gulp-load-plugins]&lt;/p&gt;
&lt;p&gt;自动刷新页面&lt;br&gt;    &lt;a href=&quot;https://github.com/vohof/gulp-livereload&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gulp-livereload&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gulp-useref&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;gulp学习与使用参考网址收录&lt;/p&gt;
&lt;h3 id=&quot;gulp&quot;&gt;&lt;a href=&quot;#gulp&quot; cl
    
    </summary>
    
      <category term="东成西就" scheme="http://HeartWalker.cc/categories/%E4%B8%9C%E6%88%90%E8%A5%BF%E5%B0%B1/"/>
    
    
      <category term="gulp" scheme="http://HeartWalker.cc/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>人之力有穷</title>
    <link href="http://HeartWalker.cc/2016/06/10/%E4%BA%BA%E4%B9%8B%E5%8A%9B%E6%9C%89%E7%A9%B7/"/>
    <id>http://HeartWalker.cc/2016/06/10/人之力有穷/</id>
    <published>2016-06-10T03:15:02.000Z</published>
    <updated>2016-06-10T03:35:40.678Z</updated>
    
    <content type="html">&lt;p&gt;想知道的太多, 想学的太多, 想玩的也太多, 人的欲望真是无穷尽, 追寻的过程中有时喜悦, 有时迷茫, 有时恐惧. 想必一个天才也不能实现它的追求, 更不要说我这样一个普通人了. 人有七情六欲, 此乃天使, 也是恶魔; 人还有生老病死, 更乃是未知的命运. &lt;/p&gt;
&lt;p&gt;我想把一切都做好, 我想知道所有知识, 我想要进行一切的娱乐, 但是那是不可能的, 人的力量终究是有穷尽的, 现实与肉体更是逃不开的枷锁, 奈何 奈何 奈何&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;想知道的太多, 想学的太多, 想玩的也太多, 人的欲望真是无穷尽, 追寻的过程中有时喜悦, 有时迷茫, 有时恐惧. 想必一个天才也不能实现它的追求, 更不要说我这样一个普通人了. 人有七情六欲, 此乃天使, 也是恶魔; 人还有生老病死, 更乃是未知的命运. &lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://HeartWalker.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="吐槽" scheme="http://HeartWalker.cc/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
</feed>
