<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HeartWalker&#39;s Blog</title>
  <subtitle>萌与正义</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://HeartWalker.cc/"/>
  <updated>2016-05-15T05:51:02.087Z</updated>
  <id>http://HeartWalker.cc/</id>
  
  <author>
    <name>Heart Walker</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css与js如何调错</title>
    <link href="http://HeartWalker.cc/2016/05/15/css%E4%B8%8Ejs%E5%A6%82%E4%BD%95%E8%B0%83%E9%94%99/"/>
    <id>http://HeartWalker.cc/2016/05/15/css与js如何调错/</id>
    <published>2016-05-15T05:09:21.000Z</published>
    <updated>2016-05-15T05:51:02.087Z</updated>
    
    <content type="html">&lt;p&gt;css 与 js 效果没有实现怎么办，出错了怎么办，可以按如下思路来解决&lt;/p&gt;
&lt;h3 id=&quot;F12_u5927_u6CD5_u597D&quot;&gt;&lt;a href=&quot;#F12_u5927_u6CD5_u597D&quot; class=&quot;headerlink&quot; title=&quot;F12大法好&quot;&gt;&lt;/a&gt;F12大法好&lt;/h3&gt;&lt;p&gt;打开 Firefox 或 Chrome 浏览器，按下F12，这是解决问题的基础&lt;/p&gt;
&lt;h3 id=&quot;u901A_u7528_u65B9_u6CD5&quot;&gt;&lt;a href=&quot;#u901A_u7528_u65B9_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;通用方法&quot;&gt;&lt;/a&gt;通用方法&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;看是否有红字报错， 一般如果看到报错信息的话问题就解决了一大半，可以根据提示快速定位问题所在，如果 不知道报错信息是什么意思可以去网上搜索&lt;/li&gt;
&lt;li&gt;确保页面上只有一个错误，如果有多个最好对代码进行逐步注释，直到最后一个错误&lt;/li&gt;
&lt;li&gt;根据现象分析问题，是哪错了，那些效果没有实现，分析出可能是什么地方出现了问题 &lt;/li&gt;
&lt;li&gt;是不是浏览器兼容性问题&lt;/li&gt;
&lt;li&gt;是不是有缓存的影响，强制刷新浏览器或清除缓存&lt;/li&gt;
&lt;li&gt;将错误的关键点提取出来，到网上搜索，最好使用 google&lt;/li&gt;
&lt;li&gt;请教朋友或大神，请注意提问的艺术，在大部分情况下请在最后才这么做&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;css_u7279_u6709&quot;&gt;&lt;a href=&quot;#css_u7279_u6709&quot; class=&quot;headerlink&quot; title=&quot;css特有&quot;&gt;&lt;/a&gt;css特有&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;使用调试工具的审查元素，查看页面结构与布局&lt;/li&gt;
&lt;li&gt;看样式是不是没用命中&lt;/li&gt;
&lt;li&gt;看样式是不是被覆盖了&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;js_u7279_u6709&quot;&gt;&lt;a href=&quot;#js_u7279_u6709&quot; class=&quot;headerlink&quot; title=&quot;js特有&quot;&gt;&lt;/a&gt;js特有&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;灵活的使用 console.log()，特别是在对程序比较了解的情况下，基本上几次就能定位问题所在&lt;/li&gt;
&lt;li&gt;使用调试工具打断点和监视变量，如果对程序不太了解或不能定位出问题的所在可以采用这种方法，但可能会耗费较久的时间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注：深入理解 css 与 js 的原理是能快速解决问题的法宝&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;css 与 js 效果没有实现怎么办，出错了怎么办，可以按如下思路来解决&lt;/p&gt;
&lt;h3 id=&quot;F12_u5927_u6CD5_u597D&quot;&gt;&lt;a href=&quot;#F12_u5927_u6CD5_u597D&quot; class=&quot;headerlink&quot; title=&quot;F12大法好
    
    </summary>
    
      <category term="东成西就" scheme="http://HeartWalker.cc/categories/%E4%B8%9C%E6%88%90%E8%A5%BF%E5%B0%B1/"/>
    
    
      <category term="调错" scheme="http://HeartWalker.cc/tags/%E8%B0%83%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>jquery中的this</title>
    <link href="http://HeartWalker.cc/2016/05/13/jquery%E4%B8%AD%E7%9A%84this/"/>
    <id>http://HeartWalker.cc/2016/05/13/jquery中的this/</id>
    <published>2016-05-13T01:29:34.000Z</published>
    <updated>2016-05-13T13:21:11.586Z</updated>
    
    <content type="html">&lt;p&gt;前天有人有问这样一个问题: 我一个网页里面有好多个前面一张图的结构，然后点击第n个加号会显示第n个子内容，点击第n个减号会隐藏第n个子内容，但是我现在总是不对，我把n弹出来，只要点加号就是0，点减号就是1，这是什么原因呀？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/jq中的this1.png&quot; alt=&quot;&quot;&gt;&lt;img src=&quot;/images/jq中的this2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;很明显问题出在这一句代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var n = $(this).index();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;只需要将代码改为:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var n = $(.add).index(this);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之所以会犯错主要有两方面原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不了解jquery中的this&lt;br&gt;  jquery中有一个很重要的概念叫隐式迭代, 在jquery内部会对调用事件的jquery DOM数组使用 each 方法, 事件函数中的this并不是调用事件的数组而是当前的原生DOM对象&lt;/li&gt;
&lt;li&gt;不了解jquery中的index方法&lt;br&gt;  调用index()会搜索匹配的元素，并返回相应元素的索引值，从0开始计数。&lt;br&gt;  如果不给 index() 方法传递参数，那么返回值就是这个jQuery对象集合中第一个元素相对于其同辈元素的位置。&lt;br&gt;如果参数是一组DOM元素或者jQuery对象，那么返回值就是传递的元素相对于原先集合的位置。&lt;br&gt;如果参数是一个选择器，那么返回值就是原先元素相对于选择器匹配元素中的位置。如果找不到匹配的元素，则返回-1。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$(this).index();相当于查找当前对象在同辈元素中的位置, 当然不能满足需求
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;前天有人有问这样一个问题: 我一个网页里面有好多个前面一张图的结构，然后点击第n个加号会显示第n个子内容，点击第n个减号会隐藏第n个子内容，但是我现在总是不对，我把n弹出来，只要点加号就是0，点减号就是1，这是什么原因呀？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/
    
    </summary>
    
      <category term="东成西就" scheme="http://HeartWalker.cc/categories/%E4%B8%9C%E6%88%90%E8%A5%BF%E5%B0%B1/"/>
    
    
      <category term="jquery" scheme="http://HeartWalker.cc/tags/jquery/"/>
    
  </entry>
  
  <entry>
    <title>new与return和函数</title>
    <link href="http://HeartWalker.cc/2016/05/09/new%E4%B8%8Ereturn%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <id>http://HeartWalker.cc/2016/05/09/new与return和函数/</id>
    <published>2016-05-09T06:29:09.000Z</published>
    <updated>2016-05-10T04:52:42.825Z</updated>
    
    <content type="html">&lt;p&gt;主要介绍函数中有无 return 与是否用 new 调用时的异同&lt;/p&gt;
&lt;h3 id=&quot;u6709new_u65E0return_28_u6784_u9020_u51FD_u6570_29&quot;&gt;&lt;a href=&quot;#u6709new_u65E0return_28_u6784_u9020_u51FD_u6570_29&quot; class=&quot;headerlink&quot; title=&quot;有new无return(构造函数)&quot;&gt;&lt;/a&gt;有new无return(构造函数)&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.name = &lt;span class=&quot;string&quot;&gt;&#39;heart&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var person = new Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(person.name);   //heart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;u6709new_u6709return_28_u5BC4_u751F_u6A21_u5F0F_29&quot;&gt;&lt;a href=&quot;#u6709new_u6709return_28_u5BC4_u751F_u6A21_u5F0F_29&quot; class=&quot;headerlink&quot; title=&quot;有new有return(寄生模式)&quot;&gt;&lt;/a&gt;有new有return(寄生模式)&lt;/h3&gt;&lt;p&gt;return 简单数据类型 和构造函数一样&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.name = &lt;span class=&quot;string&quot;&gt;&#39;heart&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var name = &lt;span class=&quot;string&quot;&gt;&#39;walker&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var person = new Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(person.name);   //heart&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;return 返回复杂数据类型(寄生模式)&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.name = &lt;span class=&quot;string&quot;&gt;&#39;heart&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name: &lt;span class=&quot;string&quot;&gt;&#39;walker&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var person = new Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(person.name);   //waker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;此时的 person 是 return出来的对象&lt;/p&gt;
&lt;h3 id=&quot;u65E0new_u65E0return&quot;&gt;&lt;a href=&quot;#u65E0new_u65E0return&quot; class=&quot;headerlink&quot; title=&quot;无new无return&quot;&gt;&lt;/a&gt;无new无return&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.name = &lt;span class=&quot;string&quot;&gt;&#39;heart&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var person = Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(person.name);   //报错&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好吧, 其实这里 Person 不应该大写, 这就是给 变量 person 赋函数 Person 的调用返回值&lt;/p&gt;
&lt;h3 id=&quot;u65E0new_u6709return&quot;&gt;&lt;a href=&quot;#u65E0new_u6709return&quot; class=&quot;headerlink&quot; title=&quot;无new有return&quot;&gt;&lt;/a&gt;无new有return&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.name = &lt;span class=&quot;string&quot;&gt;&#39;heart&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name: &lt;span class=&quot;string&quot;&gt;&#39;walker&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var person = Person();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(person.name);   //walker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt; 注: &lt;/strong&gt; 在这种情况看起来与寄生模式很相似, 但它会在全局对象中创建了一个新的名为 name 的属性, 可以通过 window.name 或 name直接访问, 当然在严格模式下由于 this 不会指向全局对象, 这段代码会报错&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;主要介绍函数中有无 return 与是否用 new 调用时的异同&lt;/p&gt;
&lt;h3 id=&quot;u6709new_u65E0return_28_u6784_u9020_u51FD_u6570_29&quot;&gt;&lt;a href=&quot;#u6709new_u65E0return_28_u6784_
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="函数" scheme="http://HeartWalker.cc/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>祸不单行</title>
    <link href="http://HeartWalker.cc/2016/05/05/%E7%A5%B8%E4%B8%8D%E5%8D%95%E8%A1%8C/"/>
    <id>http://HeartWalker.cc/2016/05/05/祸不单行/</id>
    <published>2016-05-05T00:57:39.000Z</published>
    <updated>2016-05-05T11:14:06.095Z</updated>
    
    <content type="html">&lt;p&gt;连续三天半夜被牙疼疼醒, 吃药也不管用, 终于忍不住去了医院, 最后做了根管治疗杀了神经, 不知道这颗牙齿还能撑多久. 医生说你今天晚上可以睡个安稳觉了, 谁知道当天下午就开始发起了高烧. &lt;/p&gt;
&lt;p&gt;说实话医院补牙特别是做牙套真是暴利, 正值魏则西事件持续发酵, 真是深刻的感受到在你国不能有病, 不能没钱.&lt;/p&gt;
&lt;p&gt;程序员一定要注意自己的身体啊, 最好还是不要熬夜了.&lt;/p&gt;
&lt;p&gt;感谢和我住在一起的小伙伴, 要是我自己说不定哪天就烧晕过去了也无人知道, 可怜的单身.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;连续三天半夜被牙疼疼醒, 吃药也不管用, 终于忍不住去了医院, 最后做了根管治疗杀了神经, 不知道这颗牙齿还能撑多久. 医生说你今天晚上可以睡个安稳觉了, 谁知道当天下午就开始发起了高烧. &lt;/p&gt;
&lt;p&gt;说实话医院补牙特别是做牙套真是暴利, 正值魏则西事件持续发酵, 真是
    
    </summary>
    
      <category term="生活" scheme="http://HeartWalker.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="吐槽" scheme="http://HeartWalker.cc/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>JS严格模式</title>
    <link href="http://HeartWalker.cc/2016/05/04/JS%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/"/>
    <id>http://HeartWalker.cc/2016/05/04/JS严格模式/</id>
    <published>2016-05-04T04:14:28.000Z</published>
    <updated>2016-05-05T13:19:07.614Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u5F15_u7528&quot;&gt;&lt;a href=&quot;#u5F15_u7528&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;本页内容引用自&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JavaScript高级程序设计（第3版）------------p717-p722
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结合 Node.js 与当前 ECMAScript 有少部分修改与注释    &lt;/p&gt;
&lt;h3 id=&quot;u8D77_u6E90&quot;&gt;&lt;a href=&quot;#u8D77_u6E90&quot; class=&quot;headerlink&quot; title=&quot;起源&quot;&gt;&lt;/a&gt;起源&lt;/h3&gt;&lt;p&gt;ECMAScript 5最早引入了“严格模式”（strict mode）的概念。通过严格模式，可以在函数内部 选择进行较为严格的全局或局部的错误条件检测。使用严格模式的好处是可以提早知道代码中 存在的错误，及时捕获一些可能导致编程错误的 ECMAScript行为。 &lt;/p&gt;
&lt;h3 id=&quot;u5728Node-js_u4E2D_u5F00_u542F_u4E25_u683C_u6A21_u5F0F&quot;&gt;&lt;a href=&quot;#u5728Node-js_u4E2D_u5F00_u542F_u4E25_u683C_u6A21_u5F0F&quot; class=&quot;headerlink&quot; title=&quot;在Node.js中开启严格模式&quot;&gt;&lt;/a&gt;在Node.js中开启严格模式&lt;/h3&gt;&lt;p&gt;由于浏览器兼容的问题, 严格模式在 WEB 开发中并没有被特别多的使用, 如今ECMAScript 6已经制定, ECMAScript 7 也在制定中, Node.js 对 ECMAScript 的规范支持的比较好, 并且在 Node.js 中 ECMAScript 6 的某些语法只有在严格模式下才支持 , 所以在 Node.js 中一定要开启严格模式. &lt;/p&gt;
&lt;h3 id=&quot;u8BED_u6CD5&quot;&gt;&lt;a href=&quot;#u8BED_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;p&gt;在Node.js中使用严格模式非常简单, 只需要在每个模块开头添加如下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;use strict&amp;quot;; 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u4E25_u683C_u6A21_u5F0F_u4E0E_u975E_u4E25_u683C_u6A21_u5F0F_u7684_u5F02_u540C&quot;&gt;&lt;a href=&quot;#u4E25_u683C_u6A21_u5F0F_u4E0E_u975E_u4E25_u683C_u6A21_u5F0F_u7684_u5F02_u540C&quot; class=&quot;headerlink&quot; title=&quot;严格模式与非严格模式的异同&quot;&gt;&lt;/a&gt;严格模式与非严格模式的异同&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;u53D8_u91CF&quot;&gt;&lt;a href=&quot;#u53D8_u91CF&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h4&gt;&lt;p&gt;在严格模式下，什么时候创建变量以及怎么创建变量都是有限制的。首先，不允许意外创建全局变量。在非严格模式下，可以像下面这样创建全局变量：&lt;/p&gt;
&lt;p&gt;//未声明变量&lt;br&gt;//非严格模式：创建全局变量&lt;br&gt;//严格模式：抛出 ReferenceError  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message = &amp;quot;Hello world! &amp;quot;; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即使 message 前面没有 var 关键字，即使没有将它定义为某个全局对象的属性，也能将 message 创建为全局变量。但在严格模式下，如果给一个没有声明的变量赋值，那代码在执行时就会抛出 ReferenceError。&lt;br&gt;其次，不能对变量调用 delete 操作符。非严格模式允许这样操作，但会静默失败（返回 false）。 而在严格模式下，删除变量也会导致错误 (注: delete只能删除属性, 不能删除变量, 未经声明的变量实际上是全局环境的属性而并不是全局变量)。&lt;/p&gt;
&lt;p&gt;//删除变量&lt;br&gt; //非严格模式：静默失败&lt;br&gt; //严格模式：抛出 ReferenceError &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var color = &amp;quot;red&amp;quot;; delete color;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;严格模式下对变量名也有限制。特别地，不能使用 implements、interface、let、package、 private、protected、public、static 和 yield 作为变量名。这些都是保留字，将来的 ECMAScript 版本中可能会用到它们 (注: 新版本中已经部分用到了它们)。在严格模式下，用以上标识符作为变量名会导致语法错误。&lt;/p&gt;
&lt;h4 id=&quot;u5BF9_u8C61&quot;&gt;&lt;a href=&quot;#u5BF9_u8C61&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h4&gt;&lt;p&gt;在严格模式下操作对象比在非严格模式下更容易导致错误。一般来说，非严格模式下会静默失败的情形，在严格模式下就会抛出错误。因此，在开发中使用严格模式会加大早发现错误的可能性。&lt;br&gt;在下列情形下操作对象的属性会导致错误:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为只读属性赋值会抛出 TypeError; &lt;/li&gt;
&lt;li&gt;对不可配置的（nonconfigurable）的属性使用 delete 操作符会抛出 TypeError;&lt;/li&gt;
&lt;li&gt;为不可扩展的（nonextensible）的对象添加属性会抛出 TypeError。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用对象的另一个限制与通过对象字面量声明对象有关。在使用对象字面量时，属性名必须唯一。 例如：&lt;/p&gt;
&lt;p&gt;//重名属性&lt;br&gt;//非严格模式：没有错误，以第二个属性为准&lt;br&gt;//严格模式：抛出语法错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var person = {          
        name: &amp;quot;Nicholas&amp;quot;,        
        name: &amp;quot;Greg&amp;quot;           
   };  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   这里的对象 person 有两个属性，都叫 name。在非严格模式下，person 对象的 name 属性值是第 二个，而在严格模式下，这样的代码会导致语法错误。 &lt;/p&gt;
&lt;h4 id=&quot;u51FD_u6570&quot;&gt;&lt;a href=&quot;#u51FD_u6570&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h4&gt;&lt;p&gt;首先，严格模式要求命名函数的参数必须唯一。以下面这个函数为例：&lt;/p&gt;
&lt;p&gt;//重名参数&lt;br&gt;//非严格模式：没有错误，只能访问第二个参数&lt;br&gt;//严格模式：抛出语法错误    &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function sum (num, num){
     //do something
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在非严格模式下，这个函数声明不会抛出错误。通过参数名只能访问第二个参数，要访问第一个参 数必须通过 arguments 对象。&lt;br&gt;在严格模式下，arguments 对象的行为也有所不同。在非严格模式下，修改命名参数的值也会反 映到 arguments 对象中，而严格模式下这两个值是完全独立的。例如：&lt;/p&gt;
&lt;p&gt;//修改命名参数的值&lt;br&gt;//非严格模式：修改会反映到 arguments 中&lt;br&gt;//严格模式：修改不会反映到 arguments 中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function showValue(value){     
    value = &amp;quot;Foo&amp;quot;;      
    alert(value);        //&amp;quot;Foo&amp;quot;     
    alert(arguments[0]); //非严格模式：&amp;quot;Foo&amp;quot;                          
    //严格模式：&amp;quot;Hi&amp;quot; 
}  
showValue(&amp;quot;Hi&amp;quot;);  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上代码中，函数 showValue()只有一个命名参数 value。调用这个函数时传入了一个参数”Hi”， 这个值赋给了 value。而在函数内部，value 被改为”Foo”。在非严格模式下，这个修改也会改变 arguments[0]的值，但在严格模式下，arguments[0]的值仍然是传入的值。&lt;br&gt;另一个变化是淘汰了 arguments.callee 和 arguments.caller(注: 已被废弃)。在非严格模式下，这两个属 性一个引用函数本身，一个引用调用函数。而在严格模式下，访问哪个属性都会抛出 TypeError。 例如：&lt;/p&gt;
&lt;p&gt;//访问 arguments.callee&lt;br&gt;//非严格模式：没有问题&lt;br&gt;//严格模式：抛出 TypeError  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function factorial(num){     
    if (num &amp;lt;= 1) {         
        return 1;     
        } else {         
            return num * arguments.callee(num-1)     
        }
    }  
var result=factorial(5);  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似地，尝试读写函数的 caller 属性，也会导致抛出 TypeError。所以，对于上面的例子而言， 访问 factorial.caller 也会抛出错误。&lt;br&gt; 与变量类似，严格模式对函数名也做出了限制，不允许用 implements、interface、let、package、 private、protected、public、static 和 yield 作为函数名。&lt;br&gt; 对函数的最后一点限制，就是只能在脚本的顶级和在函数内部声明函数。也就是说，在 if 语句中 声明函数会导致语法错误：&lt;/p&gt;
&lt;p&gt;//在 if 语句中声明函数&lt;br&gt;//非严格模式：将函数提升到 if 语句外部&lt;br&gt;//严格模式：抛出语法错误  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (true){     
    function doSomething(){
            //...     
        } 
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在非严格模式下，以上代码能在所有浏览器中运行，但在严格模式下会导致语法错误    &lt;/p&gt;
&lt;h4 id=&quot;eval_28_29&quot;&gt;&lt;a href=&quot;#eval_28_29&quot; class=&quot;headerlink&quot; title=&quot;eval()&quot;&gt;&lt;/a&gt;eval()&lt;/h4&gt;&lt;p&gt;饱受诟病的 eval()函数在严格模式下也得到了提升。最大的变化就是它在包含上下文中不再创建 变量或函数。例如：&lt;/p&gt;
&lt;p&gt;//使用 eval()创建变量&lt;br&gt;//非严格模式：弹出对话框显示 10&lt;br&gt;//严格模式：调用 alert(x)时会抛出 ReferenceError &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function doSomething(){     
    eval(&amp;quot;var x=10&amp;quot;);     
    alert(x); 
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果是在非严格模式下，以上代码会在函数 doSomething()中创建一个局部变量 x，然后 alert() 还会显示该变量的值。但在严格模式下，在 doSomething()函数中调用 eval()不会创建变量 x，因此 调用 alert()会导致抛出 ReferenceError，因为 x 没有定义。&lt;br&gt; 可以在 eval()中声明变量和函数，但这些变量或函数只能在被求值的特殊作用域中有效，随后就 将被销毁。因此，以下代码可以运行，没有问题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;quot;use strict&amp;quot;; 
var result = eval(&amp;quot;var x=10, y=11; x+y&amp;quot;); 
alert(result); //21  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里在 eval()中声明了变量 x 和 y，然后将它们加在一起，返回了它们的和。于是，result 变 量的值是 21，即 x 和 y 相加的结果。而在调用 alert()时，尽管 x 和 y 已经不存在了，result 变量 的值仍然是有效的。 &lt;/p&gt;
&lt;h4 id=&quot;eval_u4E0Earguments&quot;&gt;&lt;a href=&quot;#eval_u4E0Earguments&quot; class=&quot;headerlink&quot; title=&quot;eval与arguments&quot;&gt;&lt;/a&gt;eval与arguments&lt;/h4&gt;&lt;p&gt;严格模式已经明确禁止使用 eval 和 arguments 作为标识符，也不允许读写它们的值。例如：&lt;/p&gt;
&lt;p&gt;//把 eval 和 arguments 作为变量引用&lt;br&gt;//非严格模式：没问题，不出错&lt;br&gt;//严格模式：抛出语法错误 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var eval = 10; 
var arguments = &amp;quot;Hello world!&amp;quot;; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在非严格模式下，可以重写 eval，也可以给 arguments 赋值。但在严格模式下，这样做会导致语 法错误。不能将它们用作标识符，意味着以下几种使用方式都会抛出语法错误:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 var 声明;&lt;/li&gt;
&lt;li&gt;赋予另一个值;&lt;/li&gt;
&lt;li&gt;尝试修改包含的值，如使用++;&lt;/li&gt;
&lt;li&gt;用作函数名;&lt;/li&gt;
&lt;li&gt;用作命名的函数参数;&lt;/li&gt;
&lt;li&gt;在 try-catch 语句中用作例外名&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;u6291_u5236this&quot;&gt;&lt;a href=&quot;#u6291_u5236this&quot; class=&quot;headerlink&quot; title=&quot;抑制this&quot;&gt;&lt;/a&gt;抑制this&lt;/h4&gt;&lt;p&gt;JavaScript 中一个最大的安全问题，也是最容易让人迷茫的地方，就是在某些情况下如何抑制 this 的值。在非严格模式下使用函数的 apply()或 call()方法时，null 或 undefined 值会被转换为全局 对象。而在严格模式下，函数的 this 值始终是指定的值，无论指定的是什么值。例如：&lt;/p&gt;
&lt;p&gt;//访问属性&lt;br&gt;//非严格模式：访问全局属性&lt;br&gt;//严格模式：抛出错误，因为 this 的值为 null&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var color = &amp;quot;red&amp;quot;;  
function displayColor(){     
    alert(this.color); 
}   
displayColor.call(null);  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上代码向displayColor.call()中传入了null，如果在是非严格模式下，这意味着函数的this 值是全局对象。结果就是弹出对话框显示”red”。而在严格模式下，这个函数的 this 的值是 null，因 此在访问 null 的属性时就会抛出错误。&lt;/p&gt;
&lt;h4 id=&quot;u5176_u4ED6_u53D8_u5316&quot;&gt;&lt;a href=&quot;#u5176_u4ED6_u53D8_u5316&quot; class=&quot;headerlink&quot; title=&quot;其他变化&quot;&gt;&lt;/a&gt;其他变化&lt;/h4&gt;&lt;p&gt;严格模式还有其他一些变化。&lt;br&gt;首先是抛弃了 with 语句。非严格模式下的 with 语句能够改变解析标识符的路径，但在严格模式下，with 被简化掉了。因此，在严格模式下使用 with 会导致语法错误。&lt;/p&gt;
&lt;p&gt;//with 的语句用法&lt;br&gt;//非严格模式：允许&lt;br&gt;//严格模式：抛出语法错误  &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;with(location){     
    alert(href); 
}  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;严格模式也去掉了 JavaScript中的八进制字面量。以 0开头的八进制字面量过去经常会导致很多错 误。在严格模式下，八进制字面量已经成为无效的语法了。&lt;/p&gt;
&lt;p&gt;//使用八进制字面量&lt;br&gt;//非严格模式：值为 8&lt;br&gt;//严格模式：抛出语法错误 &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var value = 010;  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ECMAScript 5也修改了严格模式下 parseInt()的行为。如今，八进制字面量在 严格模式下会被当作以 0开头的十进制字面量。例如：&lt;/p&gt;
&lt;p&gt;//使用 parseInt()解析八进制字面量&lt;br&gt;//非严格模式：值为 8&lt;br&gt;//严格模式：值为 10 (注: 在 ECMAScript 5中，即使是在非严格模式下也会如此。) &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var value = parseInt(&amp;quot;010&amp;quot;);  
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u5F15_u7528&quot;&gt;&lt;a href=&quot;#u5F15_u7528&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h3&gt;&lt;p&gt;本页内容引用自&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;JavaScript高级程序设计（第3版）--------
    
    </summary>
    
      <category term="NODEJS" scheme="http://HeartWalker.cc/categories/NODEJS/"/>
    
    
  </entry>
  
  <entry>
    <title>你所不知道的new Function()</title>
    <link href="http://HeartWalker.cc/2016/04/25/%E4%BD%A0%E6%89%80%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84newFunction/"/>
    <id>http://HeartWalker.cc/2016/04/25/你所不知道的newFunction/</id>
    <published>2016-04-25T08:28:42.000Z</published>
    <updated>2016-04-25T09:42:47.533Z</updated>
    
    <content type="html">&lt;p&gt;所有懂js的都知道创建函数有三种方式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数声明式
函数表达式
new Function()构造函数式
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与前两种的广泛被使用相比, 后一种几乎无人使用&lt;/p&gt;
&lt;h3 id=&quot;u8BED_u6CD5&quot;&gt;&lt;a href=&quot;#u8BED_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var fnName = new Function( param1, param2, ..., paramN, funcBody );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Function 构造函数所有的参数都是字符串类型的&lt;br&gt;除了最后一个参数, 所有的参数都作为生成函数的参数, 这里可以没有参数; 最后一个参数也是字符串, 表示的是生成函数的函数体&lt;/p&gt;
&lt;h3 id=&quot;u5B9E_u4F8B&quot;&gt;&lt;a href=&quot;#u5B9E_u4F8B&quot; class=&quot;headerlink&quot; title=&quot;实例&quot;&gt;&lt;/a&gt;实例&lt;/h3&gt;&lt;p&gt;带参数简单求和函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var fnSum = new Function( &amp;apos;a&amp;apos;, &amp;apos;b&amp;apos;, &amp;apos;return a + b;&amp;apos; );
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不带参数复杂求和&lt;/p&gt;
&lt;p&gt;var fnSum = new Function( ‘var total = 0, args = arguments, len = args.length;for ( var i = 0; i &amp;lt; len; i++ ) {total += args[ i ];}return total;’ );&lt;/p&gt;
&lt;p&gt;注意:   上边这段代码不是我不换行, 而是作为字符串参数它不能换行, 为了解决这段代码晦涩难懂的问题可以用连接字符串的方式&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var fnSum = new Function(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;var total = 0, &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;   args = arguments, &#39;&lt;/span&gt; + &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;   len = args.length; &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;for ( var i = 0; i &amp;lt; len; i++ ) &amp;#123; &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;   total += args[ i ]; &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;&amp;#125; &#39;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;return total; &#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;new_Function_u7684_u7F3A_u70B9&quot;&gt;&lt;a href=&quot;#new_Function_u7684_u7F3A_u70B9&quot; class=&quot;headerlink&quot; title=&quot;new Function的缺点&quot;&gt;&lt;/a&gt;new Function的缺点&lt;/h3&gt;&lt;p&gt;从上边的例子可以明显的看出来它难以理解, 难以维护, 这是它几乎不被使用的主因; 不仅如此, 它还会带来性能方面的问题: 因为这种语法要解析两次代码(第一次解析常规的ECMAScript代码, 第二次解析字符串)&lt;/p&gt;
&lt;h3 id=&quot;u4F7F_u7528new_Function&quot;&gt;&lt;a href=&quot;#u4F7F_u7528new_Function&quot; class=&quot;headerlink&quot; title=&quot;使用new Function&quot;&gt;&lt;/a&gt;使用new Function&lt;/h3&gt;&lt;p&gt;俗话说缺点也是优点, 这种方式只能解析字符串这既是它的缺点也是它的优点&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;meta charset=&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;script &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&#39;text/engin&#39;&lt;/span&gt; id=&lt;span class=&quot;string&quot;&gt;&quot;engin&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var total = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    args = arguments, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    len = args.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( var i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; len; i++ ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    total += args[ i ];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; total;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var getBody = &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; ( id ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var script = document.getElementById( id );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var body = script.innerHTML.trim();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                script.parentNode.removeChild( script );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; body;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            onload = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt; () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var fnSum = new Function( getBody( &lt;span class=&quot;string&quot;&gt;&#39;engin&#39;&lt;/span&gt; ) );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                var res = fnSum( &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                alert( res );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/head&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上例也是求和函数, 只不过把函数体字符串放到了模板中&lt;br&gt;如果你使用过 eval 就会发现它们很像是不是&lt;br&gt;我们可以在 ajax 与 跨域 方面使用到 new Function, 虽然它的性能不比eval, 但是安全性要高一些, 至少它们的作用域不一样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eval( &amp;apos;var a = 10;&amp;apos; );  
等价与
直接定义 var a = 10;

(new Function( &amp;apos;var a = 10; alert( 123 );&amp;apos; ))();
new Fucntion 等价于
定义一个函数, 在函数内部, 执行
var a = 10;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还有一个需要注意的地方是: new Function() 创建的函数作用域是全局的&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var x = &lt;span class=&quot;string&quot;&gt;&#39;global&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;fn&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var x = &lt;span class=&quot;string&quot;&gt;&#39;local&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var f = new Function(&lt;span class=&quot;string&quot;&gt;&#39;return x&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log( f() ); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fn();//global&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;变量x会先在当前函数f作用域内查找, 然后直接去全局环境查找先 x 若找不到就报错而不会在fn内查找&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;所有懂js的都知道创建函数有三种方式:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;函数声明式
函数表达式
new Function()构造函数式
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与前两种的广泛被使用相比, 后一种几乎无人使用&lt;/p&gt;
&lt;h3 id=&quot;u8BED_u6CD5&quot;&gt;&lt;a hr
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="函数" scheme="http://HeartWalker.cc/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>js事件委托/代理</title>
    <link href="http://HeartWalker.cc/2016/04/21/js%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-%E4%BB%A3%E7%90%86/"/>
    <id>http://HeartWalker.cc/2016/04/21/js事件委托-代理/</id>
    <published>2016-04-21T15:13:07.000Z</published>
    <updated>2016-04-21T15:57:46.843Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u4EC0_u4E48_u662F_u4E8B_u4EF6_u59D4_u6258&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u4E8B_u4EF6_u59D4_u6258&quot; class=&quot;headerlink&quot; title=&quot;什么是事件委托&quot;&gt;&lt;/a&gt;什么是事件委托&lt;/h3&gt;&lt;p&gt;事件委托是把原本需要监听的事件委托给父元素, 让父元素承担监听的任务&lt;/p&gt;
&lt;h3 id=&quot;u4E8B_u4EF6_u59D4_u6258_u7684_u539F_u7406&quot;&gt;&lt;a href=&quot;#u4E8B_u4EF6_u59D4_u6258_u7684_u539F_u7406&quot; class=&quot;headerlink&quot; title=&quot;事件委托的原理&quot;&gt;&lt;/a&gt;事件委托的原理&lt;/h3&gt;&lt;p&gt;事件代理用到了两个在JavaSciprt事件中的特性：事件冒泡以及目标元素。&lt;/p&gt;
&lt;p&gt;当一个元素上的事件被触发的时候，比如说鼠标点击了一个按钮，同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。任何一个事件的目标元素都是最开始的那个元素，并且它在我们的元素对象中以属性的形式出现。&lt;/p&gt;
&lt;p&gt;使用事件代理，我们可以把事件处理器添加到一个元素上，等待一个事件从它的子级元素里冒泡上来，并且可以得知这个事件是从哪个元素开始的&lt;/p&gt;
&lt;h3 id=&quot;u4E8B_u4EF6_u59D4_u6258_u7684_u4F18_u70B9&quot;&gt;&lt;a href=&quot;#u4E8B_u4EF6_u59D4_u6258_u7684_u4F18_u70B9&quot; class=&quot;headerlink&quot; title=&quot;事件委托的优点&quot;&gt;&lt;/a&gt;事件委托的优点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以方便地动态添加和修改元素，不需要因为元素的改动而修改事件绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u6CE8_u610F&quot;&gt;&lt;a href=&quot;#u6CE8_u610F&quot; class=&quot;headerlink&quot; title=&quot;注意&quot;&gt;&lt;/a&gt;注意&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不是所有的事件都能冒泡的。blur、focus、load和unload不能像其它事件一样冒泡。事实上blur和focus可以用事件捕获而非事件冒泡的方法获得（在IE之外的其它浏览器中）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在管理鼠标事件的时候有些需要注意的地方。如果你的代码处理mousemove事件的话你遇上性能瓶颈的风险可就大了，因为mousemove事件触发非常频繁。而mouseout则因为其怪异的表现而变得很难用事件代理来管理。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u4EE3_u7801_u5B9E_u73B0&quot;&gt;&lt;a href=&quot;#u4EE3_u7801_u5B9E_u73B0&quot; class=&quot;headerlink&quot; title=&quot;代码实现&quot;&gt;&lt;/a&gt;代码实现&lt;/h3&gt;&lt;p&gt;简单的事件委托&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; delegateEvent(interfaceEle, selector, &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;, fn) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(interfaceEle.addEventListener)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    interfaceEle.addEventListener(&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;, eventfn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    interfaceEle.attachEvent(&lt;span class=&quot;string&quot;&gt;&quot;on&quot;&lt;/span&gt;+&lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;, eventfn);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; eventfn(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var e = e || window.event;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var target = e.target || e.srcElement;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (matchSelector(target, selector)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(fn) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                fn.call(target, e);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * only support &lt;span class=&quot;comment&quot;&gt;#id, tagName, .className&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * and it&lt;span class=&quot;string&quot;&gt;&#39;s simple single, no combination&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;function matchSelector(ele, selector) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // if use id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (selector.charAt(0) === &quot;#&quot;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return ele.id === selector.slice(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // if use class&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (selector.charAt(0) === &quot;.&quot;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return (&quot; &quot; + ele.className + &quot; &quot;).indexOf(&quot; &quot; + selector.slice(1) + &quot; &quot;) != -1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // if use tagName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ele.tagName.toLowerCase() === selector.toLowerCase();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var odiv = document.getElementById(&quot;oDiv&quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;delegateEvent(odiv,&quot;a&quot;,&quot;click&quot;,function()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    alert(&quot;1&quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;u53C2_u8003&quot;&gt;&lt;a href=&quot;#u53C2_u8003&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/weinideai/article/details/3835839&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript的事件代理 &lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.w3cmark.com/2016/439.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;事件模型及事件代理/委托&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u4EC0_u4E48_u662F_u4E8B_u4EF6_u59D4_u6258&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u4E8B_u4EF6_u59D4_u6258&quot; class=&quot;headerlink&quot; title=&quot;什么是事件委托&quot;&gt;&lt;
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="事件" scheme="http://HeartWalker.cc/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>减少重绘与回流</title>
    <link href="http://HeartWalker.cc/2016/04/18/%E5%87%8F%E5%B0%91%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81/"/>
    <id>http://HeartWalker.cc/2016/04/18/减少重绘与回流/</id>
    <published>2016-04-18T05:46:22.000Z</published>
    <updated>2016-04-19T05:05:32.632Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u9875_u9762_u5448_u73B0_u6D41_u7A0B&quot;&gt;&lt;a href=&quot;#u9875_u9762_u5448_u73B0_u6D41_u7A0B&quot; class=&quot;headerlink&quot; title=&quot;页面呈现流程&quot;&gt;&lt;/a&gt;页面呈现流程&lt;/h3&gt;&lt;p&gt;在讨论页面重绘、回流之前。需要对页面的呈现流程有些了解，页面是怎么把html结合css等显示到浏览器上的，下面的流程图显示了浏览器对页面的呈现的处理流程。可能不同的浏览器略微会有些不同。但基本上都是类似的。&lt;br&gt;&lt;img src=&quot;/images/redraw.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;浏览器把获取到的html代码解析成1个Dom树，html中的每个tag都是Dom树中的1个节点，根节点就是我们常用的document对象(&lt;html&gt; tag)。dom树就是我们用firebug或者IE Developer Toolbar等工具看到的html结构，里面包含了所有的html tag，包括display:none隐藏，还有用JS动态添加的元素等。     &lt;/html&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;浏览器把所有样式(主要包括css和浏览器的样式设置)解析成样式结构体，在解析的过程中会去掉浏览器不能识别的样式，比如IE会去掉-moz开头的样式，而firefox会去掉_开头的样式。     &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;dom tree和样式结构体结合后构建呈现树(render tree),render tree有点类似于dom tree，但其实区别有很大，render tree能识别样式，render tree中每个node都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到render tree中。注意 visibility:hidden隐藏的元素还是会包含到render tree中的，因为visibility:hidden 会影响布局(layout)，会占有空间。根据css2的标准，render tree中的每个节点都称为box(Box dimensions)，box所有属性：width,height,margin,padding,left,top,border等。     &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一旦render tree构建完毕后，浏览器就可以根据render tree来绘制页面了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u56DE_u6D41_u4E0E_u91CD_u7ED8&quot;&gt;&lt;a href=&quot;#u56DE_u6D41_u4E0E_u91CD_u7ED8&quot; class=&quot;headerlink&quot; title=&quot;回流与重绘&quot;&gt;&lt;/a&gt;回流与重绘&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(其实我觉得叫重新布局更简单明了些)。每个页面至少需要一次回流，就是在页面第一次加载的时候。    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。&lt;/p&gt;
&lt;p&gt;注：从上面可以看出，回流必将引起重绘，而重绘不一定会引起回流。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u4EC0_u4E48_u64CD_u4F5C_u4F1A_u5F15_u8D77_u91CD_u7ED8_u3001_u56DE_u6D41&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u64CD_u4F5C_u4F1A_u5F15_u8D77_u91CD_u7ED8_u3001_u56DE_u6D41&quot; class=&quot;headerlink&quot; title=&quot;什么操作会引起重绘、回流&quot;&gt;&lt;/a&gt;什么操作会引起重绘、回流&lt;/h3&gt;&lt;p&gt;其实任何对render tree中元素的操作都会引起回流或者重绘，比如：    &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加、删除元素(回流+重绘)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;移动元素，比如改变top,left(jquery的animate方法就是,改变top,left不一定会影响回流)，或者移动元素到另外1个父元素中。(重绘+回流)    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对style的操作(对不同的属性操作，影响不一样)    &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;还有一种是用户的操作，比如改变浏览器大小，改变浏览器的字体大小等(回流+重绘)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们看看下面的代码是如何影响回流和重绘的:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var s = document.body.style; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s.padding = &lt;span class=&quot;string&quot;&gt;&quot;2px&quot;&lt;/span&gt;; // 回流+重绘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s.border = &lt;span class=&quot;string&quot;&gt;&quot;1px solid red&quot;&lt;/span&gt;; // 再一次 回流+重绘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s.color = &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;; // 再一次重绘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s.backgroundColor = &lt;span class=&quot;string&quot;&gt;&quot;#ccc&quot;&lt;/span&gt;; // 再一次 重绘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s.fontSize = &lt;span class=&quot;string&quot;&gt;&quot;14px&quot;&lt;/span&gt;; // 再一次 回流+重绘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 添加node，再一次 回流+重绘&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;document.body.appendChild(document.createTextNode(&lt;span class=&quot;string&quot;&gt;&#39;abc!&#39;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;   请注意我上面用了多少个再一次。&lt;/p&gt;
&lt;p&gt;   说到这里大家都知道回流比重绘的代价要更高，回流的花销跟render tree有多少节点需要重新构建有关系，假设你直接操作body，比如在body最前面插入1个元素，会导致整个render tree回流，这样代价当然会比较高，但如果是指body后面插入1个元素，则不会影响前面元素的回流。&lt;/p&gt;
&lt;h3 id=&quot;u806A_u660E_u7684_u6D4F_u89C8_u5668&quot;&gt;&lt;a href=&quot;#u806A_u660E_u7684_u6D4F_u89C8_u5668&quot; class=&quot;headerlink&quot; title=&quot;聪明的浏览器&quot;&gt;&lt;/a&gt;聪明的浏览器&lt;/h3&gt;&lt;p&gt;从上个实例代码中可以看到几行简单的JS代码就引起了6次左右的回流、重绘。而且我们也知道回流的花销也不小，如果每句JS操作都去回流重绘的话，浏览器可能就会受不了。所以很多浏览器都会优化这些操作，浏览器会维护1个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会把flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。&lt;/p&gt;
&lt;p&gt;虽然有了浏览器的优化，但有时候我们写的一些代码可能会强制浏览器提前flush队列，这样浏览器的优化可能就起不到作用了。当你请求向浏览器请求一些style信息的时候，就会让浏览器flush队列，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. offsetTop, offsetLeft, offsetWidth, offsetHeight
2. scrollTop/Left/Width/Height
3. clientTop/Left/Width/Height
4. width,height
5. 请求了getComputedStyle(), 或者 ie的 currentStyle
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当你请求上面的一些属性的时候，浏览器为了给你最精确的值，需要flush队列，因为队列中可能会有影响到这些值的操作。  &lt;/p&gt;
&lt;h3 id=&quot;u5982_u4F55_u51CF_u5C11_u56DE_u6D41_u3001_u91CD_u7ED8&quot;&gt;&lt;a href=&quot;#u5982_u4F55_u51CF_u5C11_u56DE_u6D41_u3001_u91CD_u7ED8&quot; class=&quot;headerlink&quot; title=&quot;如何减少回流、重绘&quot;&gt;&lt;/a&gt;如何减少回流、重绘&lt;/h3&gt;&lt;p&gt;减少回流、重绘其实就是需要减少对render tree的操作，并减少对一些style信息的请求，尽量利用好浏览器的优化策略。具体方法有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;不要1个1个改变元素的样式属性，最好直接改变className，但className是预先定义好的样式，不是动态的，如果你要动态改变一些样式，则使用cssText来改变，见下面代码：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 不好的写法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var left = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var top = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;el.style.left = left + &lt;span class=&quot;string&quot;&gt;&quot;px&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;el.style.top  = top  + &lt;span class=&quot;string&quot;&gt;&quot;px&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 比较好的写法 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;el.className += &lt;span class=&quot;string&quot;&gt;&quot; className1&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 比较好的写法 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;el.style.cssText += &lt;span class=&quot;string&quot;&gt;&quot;; left: &quot;&lt;/span&gt; + left + &lt;span class=&quot;string&quot;&gt;&quot;px; top: &quot;&lt;/span&gt; + top + &lt;span class=&quot;string&quot;&gt;&quot;px;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;让要操作的元素进行”离线处理”，处理完后一起更新，这里所谓的”离线处理”即让元素不存在于render tree中，比如：&lt;/p&gt;
&lt;p&gt; a) 使用documentFragment或div等元素进行缓存操作，这个主要用于添加元素的时候，大家应该都用过，就是先把所有要添加到元素添加到1个div(这个div也是新加的)，最后才把这个div append到body中。&lt;/p&gt;
&lt;p&gt; b) 先display:none 隐藏元素，然后对该元素进行所有的操作，最后再显示该元素。因对display:none的元素进行操作不会引起回流、重绘。所以只要操作只会有2次回流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，就先读取到变量中进行缓存，以后用的时候直接读取变量就可以了，见下面代码：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 别这样写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(循环) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    el.style.left = el.offsetLeft + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;px&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    el.style.top  = el.offsetTop  + &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;&quot;px&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 这样写好点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var left = el.offsetLeft,top  = el.offsetTop,s = el.style;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(循环) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    left += &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    top  += &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.left = left + &lt;span class=&quot;string&quot;&gt;&quot;px&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    s.top  = top  + &lt;span class=&quot;string&quot;&gt;&quot;px&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;考虑你的操作会影响到render tree中的多少节点以及影响的方式，影响越多，花费肯定就越多。比如现在很多人使用jquery的animate方法移动元素来展示一些动画效果，想想下面2种移动的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&quot;#block1&quot;&lt;/span&gt;).animate(&amp;#123;left:&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; block1是position:absolute 定位的元素，它移动会影响到它父元素下的所有子元素。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 因为在它移动过程中，所有子元素需要判断block1的z-index是否在自己的上面，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 如果是在自己的上面,则需要重绘,这里不会引起回流&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&quot;#block2&quot;&lt;/span&gt;).animate(&amp;#123;marginLeft:&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; block2是相对定位的元素,这个影响的元素与block1一样，但是因为block2非绝对定位&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 而且改变的是marginLeft属性，所以这里每次改变不但会影响重绘，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 还会引起父元素及其下元素的回流&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u5B9E_u4F8B_u6D4B_u8BD5&quot;&gt;&lt;a href=&quot;#u5B9E_u4F8B_u6D4B_u8BD5&quot; class=&quot;headerlink&quot; title=&quot;实例测试&quot;&gt;&lt;/a&gt;实例测试&lt;/h3&gt;&lt;p&gt; 在页面中添加 1000 个div&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将div缓存到documentFragment&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;1 = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt; () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var start = +new Date(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i, end, node, docfrag;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        docfrag = document.createDocumentFragment();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++ ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            node = document.createElement( &lt;span class=&quot;string&quot;&gt;&#39;div&#39;&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            docfrag.appendChild( node );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        document.body.appendChild( docfrag );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        end = +new Date();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.log( &lt;span class=&quot;string&quot;&gt;&#39;test1 = &#39;&lt;/span&gt; + ( end - start ) );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;1();        //输出 &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逐次在页面创建div&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;2 = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt; () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var start = +new Date(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            i, end, s;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; count; i++ ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // s += &lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            document.body.innerHTML += &lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        document.body.innerHTML = s;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        end = +new Date();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.log( &lt;span class=&quot;string&quot;&gt;&#39;test2 = &#39;&lt;/span&gt; + ( end - start ) );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;test&lt;/span&gt;2();        //输出&lt;span class=&quot;number&quot;&gt;670&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可见test1渲染完成只需要5秒左右, test2渲染完成需要670左右, 创建的元素数量越多, 二者差距越大, 完全不在一个数量级上&lt;/p&gt;
&lt;h3 id=&quot;u603B_u7ED3&quot;&gt;&lt;a href=&quot;#u603B_u7ED3&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;尽量少次数的操作节点结构与样式&lt;br&gt;合理的使用缓存和display:none&lt;br&gt;尽量不要操作较高层级的节点的结构与样式&lt;/p&gt;
&lt;h3 id=&quot;u53C2_u8003&quot;&gt;&lt;a href=&quot;#u53C2_u8003&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.blogjava.net/BearRui/archive/2010/05/10/320502.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;高性能WEB开发(8) - 页面呈现、重绘、回流&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u9875_u9762_u5448_u73B0_u6D41_u7A0B&quot;&gt;&lt;a href=&quot;#u9875_u9762_u5448_u73B0_u6D41_u7A0B&quot; class=&quot;headerlink&quot; title=&quot;页面呈现流程&quot;&gt;&lt;/a&gt;页面呈现流程&lt;/h3
    
    </summary>
    
      <category term="web" scheme="http://HeartWalker.cc/categories/web/"/>
    
    
      <category term="优化" scheme="http://HeartWalker.cc/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>github静态博客搭建参考网址:基于hexo的janman主题</title>
    <link href="http://HeartWalker.cc/2016/04/14/github%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%8F%82%E8%80%83%E7%BD%91%E5%9D%80-%E5%9F%BA%E4%BA%8Ehexo%E7%9A%84janman%E4%B8%BB%E9%A2%98/"/>
    <id>http://HeartWalker.cc/2016/04/14/github静态博客搭建参考网址-基于hexo的janman主题/</id>
    <published>2016-04-14T12:33:10.000Z</published>
    <updated>2016-04-14T13:51:34.944Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前三个网站若打不开, 可略过, 或自行找梯子&lt;/p&gt;
&lt;h3 id=&quot;Hexo_u642D_u5EFA&quot;&gt;&lt;a href=&quot;#Hexo_u642D_u5EFA&quot; class=&quot;headerlink&quot; title=&quot;Hexo搭建&quot;&gt;&lt;/a&gt;Hexo搭建&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo官网&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://wuchong.me/blog/2014/11/20/how-to-use-jacman/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;如何使用 Jacman 主题&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/wuchong/jacman&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jacman主题github地址&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://tengj.top/categories/hexo/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;强烈推荐嘟嘟博客hexo系列&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/poem_of_sunshine/article/details/29369785/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;简明Github Pages与Hexo教程 &lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/a2023a601ceb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;hexo–搭建&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jerryfu.net/post/search-engine-for-hexo-with-swiftype-v2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;swiftype站内搜索&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://wp.huangshiyang.com/hexo%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo常见问题解决方案&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Markdown&quot;&gt;&lt;a href=&quot;#Markdown&quot; class=&quot;headerlink&quot; title=&quot;Markdown&quot;&gt;&lt;/a&gt;Markdown&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://wowubuntu.com/markdown/#list&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Markdown 语法说明 (简体中文版)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://sspai.com/25137&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;认识与入门 Markdown&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://mahua.jser.me/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MaHua 在线markdown编辑器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前三个网站若打不开, 可略过, 或自行找梯子&lt;/p&gt;
&lt;h3 id=&quot;Hexo_u642D_u5EFA&quot;
    
    </summary>
    
      <category term="东成西就" scheme="http://HeartWalker.cc/categories/%E4%B8%9C%E6%88%90%E8%A5%BF%E5%B0%B1/"/>
    
    
  </entry>
  
  <entry>
    <title>js作用域其六:函数的四种调用模式与this</title>
    <link href="http://HeartWalker.cc/2016/04/14/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%85%B6%E5%85%AD-%E5%87%BD%E6%95%B0%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F%E4%B8%8Ethis/"/>
    <id>http://HeartWalker.cc/2016/04/14/js作用域其六-函数的四种调用模式与this/</id>
    <published>2016-04-14T11:59:42.000Z</published>
    <updated>2016-04-14T12:27:54.849Z</updated>
    
    <content type="html">&lt;h2 id=&quot;this_u6307_u5411_u8C01&quot;&gt;&lt;a href=&quot;#this_u6307_u5411_u8C01&quot; class=&quot;headerlink&quot; title=&quot;this指向谁&quot;&gt;&lt;/a&gt;this指向谁&lt;/h2&gt;&lt;p&gt;this是js中一个非常有用的关键字并且方便的关键字, 但同时也会带来一些困惑: this到底指向谁 ? 事实上&lt;strong&gt;this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象&lt;/strong&gt;  , 除去不常用的with与eval, this的指向取决于函数的四种调用模式&lt;/p&gt;
&lt;h2 id=&quot;u51FD_u6570_u7684_u56DB_u79CD_u8C03_u7528_u6A21_u5F0F&quot;&gt;&lt;a href=&quot;#u51FD_u6570_u7684_u56DB_u79CD_u8C03_u7528_u6A21_u5F0F&quot; class=&quot;headerlink&quot; title=&quot;函数的四种调用模式&quot;&gt;&lt;/a&gt;函数的四种调用模式&lt;/h2&gt;&lt;h3 id=&quot;u51FD_u6570_u6A21_u5F0F&quot;&gt;&lt;a href=&quot;#u51FD_u6570_u6A21_u5F0F&quot; class=&quot;headerlink&quot; title=&quot;函数模式&quot;&gt;&lt;/a&gt;函数模式&lt;/h3&gt;&lt;p&gt;定义一个函数, 如果单独的将其调用, 不将其与任何东西关联, 那么就是函数调用模式. 此时 this 的调用者默认就是全局对象( window )&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var num = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var num = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(this.num); //输出&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(num)       //输出&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;u65B9_u6CD5_u6A21_u5F0F&quot;&gt;&lt;a href=&quot;#u65B9_u6CD5_u6A21_u5F0F&quot; class=&quot;headerlink&quot; title=&quot;方法模式&quot;&gt;&lt;/a&gt;方法模式&lt;/h3&gt;&lt;p&gt;定义一个函数, 如果将函数赋值给一个对象的成员, 那么利用对象调用它就是方法模式. 方法模式 this 就是当前调用方法的对象&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var o = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    a: &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    f: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        console.log(this.a)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;o.f(); //输出&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在看一个例子&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var name=&lt;span class=&quot;string&quot;&gt;&quot;张三&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var obj=&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  name:&lt;span class=&quot;string&quot;&gt;&quot;李四&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  getName:&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(this.name);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.getName();               //输出：李四&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var getName=obj.getName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;getName();                  //输出：张三&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;直接调用obj.getName（），这里的this是作为对象的方法调用，所以它指向obj，this.name就是李四；obj.getName赋值给getName后，getName就变成了普通函数，所以指向的是全局的window.name，结果是张三 &lt;/p&gt;
&lt;h3 id=&quot;u6784_u9020_u5668_u6A21_u5F0F&quot;&gt;&lt;a href=&quot;#u6784_u9020_u5668_u6A21_u5F0F&quot; class=&quot;headerlink&quot; title=&quot;构造器模式&quot;&gt;&lt;/a&gt;构造器模式&lt;/h3&gt;&lt;p&gt;定义一个函数, 使用 new 来调用创建对象就是构造器( constructor )模式 . 构造器模式 this 就是 new 出来的新的对象&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;myClass&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  this.name=&lt;span class=&quot;string&quot;&gt;&quot;张三&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var child=new myClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(child.name);    //输出：张三&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是当构造函数中有 return 时, 情况又有些不同:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果 return 后面是&lt;strong&gt;基本数据类型&lt;/strong&gt;, 忽略, 和没写一样&lt;/li&gt;
&lt;li&gt;如果 return 后面是一个有效的引用类型, 那么无论构造函数中写什么内容, 都返回 return 后面的对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;myClass&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      this.name=&lt;span class=&quot;string&quot;&gt;&quot;张三&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name: &lt;span class=&quot;string&quot;&gt;&quot;李四&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var child=new myClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(child.name);    //输出：李四&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;u4E0A_u4E0B_u6587_u6A21_u5F0F_28call_u4E0Eapply_29&quot;&gt;&lt;a href=&quot;#u4E0A_u4E0B_u6587_u6A21_u5F0F_28call_u4E0Eapply_29&quot; class=&quot;headerlink&quot; title=&quot;上下文模式(call与apply)&quot;&gt;&lt;/a&gt;上下文模式(call与apply)&lt;/h3&gt;&lt;p&gt;　　每个函数都包含两个非继承而来的方法：apply()和 call(). 这两个方法的用途都是在特定的作 用域中调用函数，实际上等于设置函数体内 this 对象的值.&lt;br&gt;　　首先，apply()方法接收两个参数：一个 是在其中运行函数的作用域，另一个是参数数组. 其中，第二个参数可以是 Array 的实例，也可以是 arguments 对象&lt;br&gt;　　call()方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同. 对于 call() 方法而言，第一个参数是 this 值没有变化，变化的是其余参数都直接传递给函数&lt;/p&gt;
&lt;p&gt;调用方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数名.apply(参数1,参数2);&lt;/li&gt;
&lt;li&gt;函数名.call(参数1, 参数2, …,参数n);&lt;br&gt;例:&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var name = &lt;span class=&quot;string&quot;&gt;&quot;张三&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;foo&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            console.log( this.name );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var o = &amp;#123; name: &lt;span class=&quot;string&quot;&gt;&#39;李四&#39;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.apply();               //张三&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.apply( null );          //张三&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.apply( o );            //李四&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;foo.call( o );              //李四&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;u4E25_u683C_u6A21_u5F0F_u4E0B_u7684this&quot;&gt;&lt;a href=&quot;#u4E25_u683C_u6A21_u5F0F_u4E0B_u7684this&quot; class=&quot;headerlink&quot; title=&quot;严格模式下的this&quot;&gt;&lt;/a&gt;严格模式下的this&lt;/h2&gt;&lt;p&gt;在严格模式下, 当this值为null或undefined时，不会再将其强制转换为全局对象. 也就是说，this保留了它的原始值，也因此可能会导致一些依赖于强制转换的代码发生错误. 例如：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;　　var color = &lt;span class=&quot;string&quot;&gt;&quot;red&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;sayColor&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;use strict&quot;&lt;/span&gt;;                 //开启严格模式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　alert(this.color);           // 严格模式下，this不会指向window&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　// 以下两种情况，在严格模式下都抛出错误&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　sayColor();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　sayColor.call(null);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　根本而言，this值必须赋值，否则将保留undefined值. 这意味着调用构造函数时若漏掉了new关键字也会导致错误：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;　　&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; Person(name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;use strict&quot;&lt;/span&gt;;                      //开启严格模式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　this.name = name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;　　var me = Person(&lt;span class=&quot;string&quot;&gt;&quot;Nicholas&quot;&lt;/span&gt;);       // 严格模式下导致错误&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　在这段代码里，调用Person构造函数时缺少了new关键字，此时this值为undefined. 由于你不能给undefined添加属性，这段代码抛出了一个错误. 在非严格模式下，this会强制转换为全局对象，因此name属性能够被正确赋值为全局变量. &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this_u6307_u5411_u8C01&quot;&gt;&lt;a href=&quot;#this_u6307_u5411_u8C01&quot; class=&quot;headerlink&quot; title=&quot;this指向谁&quot;&gt;&lt;/a&gt;this指向谁&lt;/h2&gt;&lt;p&gt;this是js中一个非常有用的关键字并且
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="作用域" scheme="http://HeartWalker.cc/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>js作用域其五:仿块级作用域(沙箱模式)</title>
    <link href="http://HeartWalker.cc/2016/04/12/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%85%B6%E4%BA%94-%E4%BB%BF%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://HeartWalker.cc/2016/04/12/js作用域其五-仿块级作用域/</id>
    <published>2016-04-12T04:55:41.000Z</published>
    <updated>2016-04-12T13:53:24.178Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u4EC0_u4E48_u662F_u4EFF_u5757_u7EA7_u4F5C_u7528_u57DF&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u4EFF_u5757_u7EA7_u4F5C_u7528_u57DF&quot; class=&quot;headerlink&quot; title=&quot;什么是仿块级作用域&quot;&gt;&lt;/a&gt;什么是仿块级作用域&lt;/h3&gt;&lt;p&gt;前面说过, 在JS中并没有块级作用域, 因此用 var 定义的变量可能会带来变量名污染的问题,  有些时候我们会使用闭包, 但是闭包会引起内存方面的一些问题, 自调用匿名函数可以用来模拟块级作用域, 这种方法通常又被称作沙箱模式或沙盒模式, 仿块级作用域可以看做是闭包的一种特殊用法&lt;/p&gt;
&lt;p&gt;使用沙箱后, 在内部定义的代码, 访问数据; 在沙箱内部是一个完整的生态链, 也就是说只要保证变量有 var 那么内部和外部就完全隔离开了, 如果要声明多个数据在沙箱中 也不会出现污染全局的问题&lt;/p&gt;
&lt;h3 id=&quot;u57FA_u672C_u8BED_u6CD5&quot;&gt;&lt;a href=&quot;#u57FA_u672C_u8BED_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;基本语法&quot;&gt;&lt;/a&gt;基本语法&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     //这里是块级作用域 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然而下面却会出错&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     //这里是块级作用域 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;();    //出错！&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这段代码会导致语法错误，是因为 JavaScript将 function 关键字当作一个函数声明的开始，而函 数声明后面不能跟圆括号. 然而，函数表达式的后面可以跟圆括号. 要将函数声明转换成函数表达式， 只要给它加上一对圆括号即可.  &lt;/p&gt;
&lt;h3 id=&quot;u5B9E_u4F8B_u8BB2_u89E3&quot;&gt;&lt;a href=&quot;#u5B9E_u4F8B_u8BB2_u89E3&quot; class=&quot;headerlink&quot; title=&quot;实例讲解&quot;&gt;&lt;/a&gt;实例讲解&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var sum = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt; () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( var i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++ ) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        sum += i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(sum);    //输出: &lt;span class=&quot;number&quot;&gt;5050&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log( i );    //报错: i is not defined&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上例定义了一个全局变量 sum, 然后定义了一个匿名函数并立即执行, 求出0-100的和并赋值给sum, 在匿名函数结束时, 匿名函数内定义的局部变量会立即被销毁, 然后打印出 sum 和 i, 由于在全局环境中并不存在 i, 所以会报错. &lt;/p&gt;
&lt;p&gt;这种做法看起来和闭包没有什么不同, 但是它可以减少闭包占用的内存问题，因为没有指向匿名函数的引用. 只要函 数执行完毕，就可以立即销毁其作用域链了&lt;/p&gt;
&lt;p&gt;这种技术经常在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数.  一般来说，我们都应该尽量少向全局作用域中添加变量和函数. 在一个由很多开发人员共同参与的大型 应用程序中，过多的全局变量和函数很容易导致命名冲突. 而通过创建私有作用域，每个开发人员既可 以使用自己的变量，又不必担心搞乱全局作用域&lt;/p&gt;
&lt;h3 id=&quot;u53C2_u8003&quot;&gt;&lt;a href=&quot;#u53C2_u8003&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;JavaScript高级程序设计(第三版)———— p185-p186&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u4EC0_u4E48_u662F_u4EFF_u5757_u7EA7_u4F5C_u7528_u57DF&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u4EFF_u5757_u7EA7_u4F5C_u7528_u57DF&quot; class=&quot;heade
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="作用域" scheme="http://HeartWalker.cc/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>JS中值类型与引用类型进阶之函数传参</title>
    <link href="http://HeartWalker.cc/2016/04/06/JS%E4%B8%AD%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BF%9B%E9%98%B6%E4%B9%8B%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/"/>
    <id>http://HeartWalker.cc/2016/04/06/JS中值类型与引用类型进阶之函数传参/</id>
    <published>2016-04-06T04:51:07.000Z</published>
    <updated>2016-04-25T11:18:44.150Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前一段时间写过一篇博客介绍&lt;a href=&quot;/2016/03/28/JS中值类型和引用类型与赋值/&quot;&gt;JS中值类型与引用类型和它们的赋值&lt;/a&gt;, 下面通过一个案例说明它们在函数传参方面的应用&lt;/p&gt;
&lt;h3 id=&quot;u6848_u4F8B&quot;&gt;&lt;a href=&quot;#u6848_u4F8B&quot; class=&quot;headerlink&quot; title=&quot;案例&quot;&gt;&lt;/a&gt;案例&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;Name( obj )&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.name = &lt;span class=&quot;string&quot;&gt;&#39;jim&#39;&lt;/span&gt;;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj = new Object(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.name = &lt;span class=&quot;string&quot;&gt;&#39;tom&#39;&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var person = new Object();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;Name( person );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert( person.name );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;运行结果: 窗口弹出jim&lt;/p&gt;
&lt;h3 id=&quot;u5206_u6790&quot;&gt;&lt;a href=&quot;#u5206_u6790&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h3&gt;&lt;p&gt;首先进行预解析, 然后执行, 步骤如下&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;Name( obj )&amp;#123;    //&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;.  将person的值赋值给obj, 相当于执行obj = person, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            //    此时person与obj的值都是引用并指向同一个对象 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.name = &lt;span class=&quot;string&quot;&gt;&#39;jim&#39;&lt;/span&gt;;       //&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;. 给空对象添加属性name, 并赋值jim&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj = new Object();     //&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;. 创建第二个新的空对象, 并将它的引用赋值给obj, 注意: 此时person的引用并未改变&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    obj.name = &lt;span class=&quot;string&quot;&gt;&#39;tom&#39;&lt;/span&gt;;       //&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;. 给第二个空对象添加属性name, 并赋值tom , person指向的空对象的name属性并没有发生变化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var person = new Object();   //&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;. 定义变量person并给其赋值为一个空对象, 注意: 此处是将空对象的引用赋值给person&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;Name( person );          //&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;. 执行&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;Name( person ) ,调用&lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;Name函数并给其传参 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert( person.name );       //&lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;. 弹出person引用指向的对象的name属性的值&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这个案例的关键是要理解函数传参: 函数传参是将实参的值赋值给形参, 实参与形参的在内存中的存储的地址并不相同&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;前一段时间写过一篇博客介绍&lt;a href=&quot;/2016/03/28/JS中值类型和引用类型与赋值/&quot;&gt;J
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="变量类型" scheme="http://HeartWalker.cc/tags/%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端优化(持续更新中)</title>
    <link href="http://HeartWalker.cc/2016/04/06/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    <id>http://HeartWalker.cc/2016/04/06/前端优化/</id>
    <published>2016-04-05T17:39:44.000Z</published>
    <updated>2016-05-15T10:23:38.129Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u6027_u80FD_u9EC4_u91D1_u6CD5_u5219&quot;&gt;&lt;a href=&quot;#u6027_u80FD_u9EC4_u91D1_u6CD5_u5219&quot; class=&quot;headerlink&quot; title=&quot;性能黄金法则&quot;&gt;&lt;/a&gt;性能黄金法则&lt;/h3&gt;&lt;p&gt;只有10%-20%的最终用户响应时间花在了下载HTML文档上, 其余的80%-90%时间花在了下载页面中的所有组件上&lt;/p&gt;
&lt;h3 id=&quot;u51CF_u5C11HTTP_u8BF7_u6C42&quot;&gt;&lt;a href=&quot;#u51CF_u5C11HTTP_u8BF7_u6C42&quot; class=&quot;headerlink&quot; title=&quot;减少HTTP请求&quot;&gt;&lt;/a&gt;减少HTTP请求&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;合并背景图片&lt;/strong&gt;&lt;br&gt;就是常说的精灵图, 将多个背景图片合并到一张图片上, 然后利用background-position来定位它. 有趣的是它还会降低图片总的下载量, 虽然合并图片后图片中的空白会增多,  但是图片自身的开销(颜色表, 格式信息,等等)会减少.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并样式表&lt;/strong&gt;&lt;br&gt;将多个css文件合并成一个css文件 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并脚本&lt;/strong&gt;&lt;br&gt;将多个js文件合并成一个js文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图片地图(图像映射)&lt;/strong&gt;&lt;br&gt;通过&amp;lt; img /&amp;gt;后添加&amp;lt; map &amp;gt;和&amp;lt; area &amp;gt;设置。&lt;br&gt;&amp;lt; map &amp;gt;元素表明映射的开始&lt;br&gt;&amp;lt; area &amp;gt;元素表明每个区域，如果要把一个图片分4个区域，则用4个area。&lt;br&gt;&amp;lt; map &amp;gt;元素只有一个name属性.&lt;br&gt;下面介绍area元素的属性：&lt;br&gt;(1) shape：必须的属性，用于描述区域的形状，rectangle\poly\circle\default可选,default指的是还没有被定义的区域。&lt;br&gt;(2) coords：指定区域的坐标。比如矩形有4个坐标，前两个是左上角的x,y坐标，后两个是右下角的x,y坐标。&lt;br&gt;(3) href和nohref：href指定目的的链接，如果不指定href属性，则需要指定nohref，nohref=”nohref”&lt;br&gt;(4) target：和&amp;lt; a &amp;gt;一样。&lt;br&gt;注：&lt;br&gt;(1)在&amp;lt; img&amp;gt;中设置usemap属性。&lt;br&gt;(2)在&amp;lt; map&amp;gt;中设置name属性。&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;img src=&lt;span class=&quot;string&quot;&gt;&quot;planets.jpg&quot;&lt;/span&gt; border=&lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt; usemap=&lt;span class=&quot;string&quot;&gt;&quot;#planetmap&quot;&lt;/span&gt; alt=&lt;span class=&quot;string&quot;&gt;&quot;Planets&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;map name=&lt;span class=&quot;string&quot;&gt;&quot;planetmap&quot;&lt;/span&gt; id=&lt;span class=&quot;string&quot;&gt;&quot;planetmap&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;area shape=&lt;span class=&quot;string&quot;&gt;&quot;circle&quot;&lt;/span&gt; coords=&lt;span class=&quot;string&quot;&gt;&quot;180,139,14&quot;&lt;/span&gt; href =&lt;span class=&quot;string&quot;&gt;&quot;venus.html&quot;&lt;/span&gt; alt=&lt;span class=&quot;string&quot;&gt;&quot;Venus&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;area shape=&lt;span class=&quot;string&quot;&gt;&quot;circle&quot;&lt;/span&gt; coords=&lt;span class=&quot;string&quot;&gt;&quot;129,161,10&quot;&lt;/span&gt; href =&lt;span class=&quot;string&quot;&gt;&quot;mercur.html&quot;&lt;/span&gt; alt=&lt;span class=&quot;string&quot;&gt;&quot;Mercury&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;area shape=&lt;span class=&quot;string&quot;&gt;&quot;rect&quot;&lt;/span&gt; coords=&lt;span class=&quot;string&quot;&gt;&quot;0,0,110,260&quot;&lt;/span&gt; href =&lt;span class=&quot;string&quot;&gt;&quot;sun.html&quot;&lt;/span&gt; alt=&lt;span class=&quot;string&quot;&gt;&quot;Sun&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/map&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u5185_u5BB9_u53D1_u5E03_u7F51_u7EDC_28CDN_29&quot;&gt;&lt;a href=&quot;#u5185_u5BB9_u53D1_u5E03_u7F51_u7EDC_28CDN_29&quot; class=&quot;headerlink&quot; title=&quot;内容发布网络(CDN)&quot;&gt;&lt;/a&gt;内容发布网络(CDN)&lt;/h3&gt;&lt;p&gt;　　毫无疑问用户与服务器的物理距离越近, 则HTTP响应时间越短. 但是不要尝试使用分布式架构重新设计Web应用程序, 这样的应用程序决定了重新设计将带来令人恐惧的任务, 如同步会话状态和在服务器放置地点之间复制数据库事务. 重新设计这一步骤可能会推迟-甚至无法实现缩短用户和你的内容之间的距离这一愿望.&lt;br&gt;　　更靠谱更简单的方法是将组件Web服务器分散开.&lt;br&gt;　　内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来更有效的给用户发送内容. 选择用来发送内容的服务器是基于网络可用度的测量. 例如：选跳数（hop）最少的或者响应时间最快的服务器&lt;br&gt;CDN用于发布静态内容, 如图片 脚本 样式表 和Flash, 除了缩短响应时间外, 它们的服务包括备份 扩展存储能力和进行缓存.  CDN还有利于缓和Web流量峰值压力. &lt;/p&gt;
&lt;h3 id=&quot;u6DFB_u52A0Expires_u5934_u548CCache-control&quot;&gt;&lt;a href=&quot;#u6DFB_u52A0Expires_u5934_u548CCache-control&quot; class=&quot;headerlink&quot; title=&quot;添加Expires头和Cache-control&quot;&gt;&lt;/a&gt;添加Expires头和Cache-control&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;对于静态组件：通过设置一个遥远的将来时间作为 Expires 来实现永不失效
多余动态组件：用合适的 Cache-Control HTTP头来让浏览器进行条件性的请求
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Web服务器使用Expires头来告诉Web客户端它可以使用一个组件的的当前副本, 直到指定的时间为止, 如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Expires: Thu, 15 Apr 2030 20:00:00 GMT
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一个有效期非常长久的Expires头, 它告诉浏览器这个响应在2030年4月15日前不会改变&lt;/p&gt;
&lt;p&gt;但是因为Expires头使用了一个特定的时间, 它要求服务器和客户端的时钟严格同步. 另外, 过期日期需要经常检查, 并且一旦未来这一天到来了, 还需要在服务器配置中提供一个新的日期.&lt;/p&gt;
&lt;p&gt;因此在 HTTP1.1中引入了Cache-control头来克服Expires头的限制. Cache-control使用max-age指令指定组件被缓存多久. 它以秒为单位定义了一个更新床. 如果从组件被请求开始过去的秒数小于max-age, 浏览器就使用缓存的版本, 这就避免了额外的HTTP请求. 一个长久的 max-age头 可以将刷新窗设置为未来 10 年. &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cache-Control:  max-age= 315360000
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果Expires和 max-age同时出现, max-age指令将重写Expires头&lt;/p&gt;
&lt;p&gt;如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了图片 脚本和样式表从请求时间起10年的有效期：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;FilesMatch &amp;quot;\.(gif|gpg|js|css)$&amp;quot;&amp;gt;
ExpiresDefault &amp;quot;access plus 10 years&amp;quot;
&amp;lt;FilesMatch&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你用一个遥远的未来时间做有效期，就不得不在组件发生变化后及时修改组件的文件名; 为能够获取最新的文件，最有效的解决方案是修改其所有链接，这样，全新的请求将从原始服务器下载最新的内容&lt;/p&gt;
&lt;h3 id=&quot;u5E94_u7528_u7F13_u5B58cache_manifest&quot;&gt;&lt;a href=&quot;#u5E94_u7528_u7F13_u5B58cache_manifest&quot; class=&quot;headerlink&quot; title=&quot;应用缓存cache manifest&quot;&gt;&lt;/a&gt;应用缓存cache manifest&lt;/h3&gt;&lt;p&gt;H5&lt;/p&gt;
&lt;h3 id=&quot;Gzip_u538B_u7F29&quot;&gt;&lt;a href=&quot;#Gzip_u538B_u7F29&quot; class=&quot;headerlink&quot; title=&quot;Gzip压缩&quot;&gt;&lt;/a&gt;Gzip压缩&lt;/h3&gt;&lt;p&gt;从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Accept-Encoding: gzip
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Content-Encoding: gzip
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gzip是目前最常见的高效压缩方法，由GNU项目开发的免费格式, 并被标准化为 RFC 1952 。 &lt;/p&gt;
&lt;p&gt;压缩脚本和样式表是非常值得的，同时还有XML和JSON在内的文本。图片和PDF不应该压缩，因为它们本来就已经被压缩了。但是压缩本身也有成本–服务器要压缩,客户端要解压; 根据经验通常对大于1KB或2KB的文件进行压缩.&lt;/p&gt;
&lt;p&gt;代理缓存问题：&lt;br&gt;Web服务器基于Accept-Encoding来检测是否对响应进行压缩。不管是否压缩过，浏览器都会基于响应中的其他HTTP头如Expires和Cache-Control来缓存响应。由于代理服务器的存在, 代理服务器在响应设置gzip压缩或未设置gzip压缩的请求时会产生混乱, 因此需要在服务器的Vary响应头中包含Accept-Encoding, 这样服务器会给没有设置gzip压缩的请求缓存未压缩内容, 给设置gzip压缩的的请求缓存压缩内容。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Vary: Accept-Encoding
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u5C06_u6837_u5F0F_u8868_u653E_u5230_u9876_u90E8&quot;&gt;&lt;a href=&quot;#u5C06_u6837_u5F0F_u8868_u653E_u5230_u9876_u90E8&quot; class=&quot;headerlink&quot; title=&quot;将样式表放到顶部&quot;&gt;&lt;/a&gt;将样式表放到顶部&lt;/h3&gt;&lt;p&gt;将样式表放到顶部对于加载页面所需的实际时间没有太多影响，它影响更多的是浏览器对这些组件顺序的反应。&lt;br&gt;为避免当样式变化时重绘页面中的元素，浏览器会等待位于底部的样式表加载完成后才会呈现，这时浏览器会延迟任何可视化组件。&lt;br&gt;实际上，用户感觉缓慢的页面反而是可视化组建加载得更快的页面。使用LINK标签将样式表放在文档的HEAD中可以解决该问题。&lt;br&gt;可参考本人博客 &lt;a href=&quot;/2016/03/08/link与@import引入css/&quot;&gt;link与@import引入css&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;u5C06_u811A_u672C_u653E_u5728_u5E95_u90E8&quot;&gt;&lt;a href=&quot;#u5C06_u811A_u672C_u653E_u5728_u5E95_u90E8&quot; class=&quot;headerlink&quot; title=&quot;将脚本放在底部&quot;&gt;&lt;/a&gt;将脚本放在底部&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;并行下载&lt;/strong&gt;&lt;br&gt;对响应时间影响最大的是页面中组件的数量，如果一个Web页面平均地将其组件分别放在两个，整体响应时间将可以减少大约一半。但并行下载数量并不是越多越快，因为增加并行下载数销的，其优劣取决于带宽和cpu速度。&lt;br&gt;&lt;strong&gt;脚本阻塞下载&lt;/strong&gt;&lt;br&gt;并行下载组件的优点是很明显的，然而，在下载脚本时并行下载实际上被禁用的。即使使用了不同的主机名，浏览器也不会启动其他的下载。其中一个原因是，脚本可能使用document.write来修改，因此浏览器会等待，已确保页面能够恰当地布局。另一个原因是为了保证脚本能够按照正确行。&lt;/p&gt;
&lt;p&gt;在使用脚本时，对于所有位于脚本以下的内容，逐步呈现都被阻塞了。将脚本放在页面的底部，这不会阻止页面内容的呈现, 而且页面中的可视内容可以尽早下载。但是有时很难将脚本移到底部，例如document.write向页面中插入内容，就不能移动到其页面后面的位置了。&lt;/p&gt;
&lt;p&gt;注: 现在的最新浏览器已经支持并行下载, 并能保证它们的执行顺序&lt;/p&gt;
&lt;h3 id=&quot;u907F_u514D_u4F7F_u7528CSS_u8868_u8FBE_u5F0F&quot;&gt;&lt;a href=&quot;#u907F_u514D_u4F7F_u7528CSS_u8868_u8FBE_u5F0F&quot; class=&quot;headerlink&quot; title=&quot;避免使用CSS表达式&quot;&gt;&lt;/a&gt;避免使用CSS表达式&lt;/h3&gt;&lt;p&gt;基本已经无人使用&lt;/p&gt;
&lt;p&gt;从IE5开始支持，但 从IE8起就不推荐使用了 。&lt;/p&gt;
&lt;p&gt;表达式最大的问题是它们经常被重复计算，比我们想象的次数还要多。&lt;/p&gt;
&lt;h3 id=&quot;u4F7F_u7528_u5916_u90E8JavaScript_u4E0ECSS&quot;&gt;&lt;a href=&quot;#u4F7F_u7528_u5916_u90E8JavaScript_u4E0ECSS&quot; class=&quot;headerlink&quot; title=&quot;使用外部JavaScript与CSS&quot;&gt;&lt;/a&gt;使用外部JavaScript与CSS&lt;/h3&gt;&lt;p&gt;纯粹而言使用内联脚本与样式更快一些&lt;/p&gt;
&lt;p&gt;但是使用外部的脚本与样式表可以设置缓存, 并且如果你的网站中的每一个页面都使用了相同的JavaScript和Css，使用外部文件可以提高这些组件的重用率, 因为当用户在页面间浏览时，JavaScript和Css组件已经位于浏览器的缓存中了&lt;/p&gt;
&lt;p&gt;而且使用外部脚本与样式表符合行为 样式 结构分离, 有利于网站的维护&lt;/p&gt;
&lt;h3 id=&quot;u51CF_u5C11DNS_u67E5_u627E&quot;&gt;&lt;a href=&quot;#u51CF_u5C11DNS_u67E5_u627E&quot; class=&quot;headerlink&quot; title=&quot;减少DNS查找&quot;&gt;&lt;/a&gt;减少DNS查找&lt;/h3&gt;&lt;p&gt;Internet是通过IP地址来查找服务器的。由于IP地址很难记忆，通常使用包含主机名的URL来取代它，但当浏览器发送其请求时，IP地址仍然是必需的。这就是Domain Name System(DNS) 所处的角色。DNS也有开销，通常浏览器查找一个给定的主机名的IP地址要花费20-120毫秒。响应时间依赖于DNS解析器（通常由你的ISP提供）、它所承担的请求压力、你与它之间的距离和你的带宽速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用DNS缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DNS查找可以被缓存起来提高性能。这种缓存可以发生在由你的ISP或局域网中的一台特殊的缓存服务器上，但这里探讨的是发生在独立用户的计算机上的DNS缓存。在用户请求了一个主机名之后，DNS信息会留在操作系统的DNS缓存中，之后对于该主机名的请求将无需进行过多的DNS查找，至少短时间内不需要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;影响DNS缓存的因素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，服务器可以表明记录可以被缓存多久。查找返回的DNS记录包含了一个存活时间（Time-to-live,TTL）值。该值告诉客户端可以对该记录缓存多久，尽管操作系统缓存会考虑TTL值，但浏览器通常忽略该值，并设置它自己的时间限制。另外浏览器对缓存的DNS记录的数量也有限制，TTL设置值通常是1天。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适当的主机名数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 当客户端的DNS缓存为空（浏览器和操作系统都是）时，DNS查找的数量与Web页面中唯一主机名的数量相等。这包括页面URL、图片、脚本文件、样式表、Flash对象等的主机名。减少唯一主机名的数量就可以就可以减少DNS查找的数量。&lt;/p&gt;
&lt;p&gt;通过使用Keep-Alive和较少的域名来减少DNS查找&lt;/p&gt;
&lt;h3 id=&quot;u7CBE_u7B80JavaScript_u4E0ECSS&quot;&gt;&lt;a href=&quot;#u7CBE_u7B80JavaScript_u4E0ECSS&quot; class=&quot;headerlink&quot; title=&quot;精简JavaScript与CSS&quot;&gt;&lt;/a&gt;精简JavaScript与CSS&lt;/h3&gt;&lt;p&gt;精简JavaScript通常也叫作压缩JavaScript, 不过请与Gzip压缩区分开&lt;/p&gt;
&lt;p&gt;精简JavaScript是从代码中移除不必要的字符以减少其大小，进而改善加载时间的实践。在代码被精简后，所有的注释以及不必要的空白字符（空格、换行和制表符）都将被移除。对于JavaScript而言，这可以改善响应时间效率，因为需要下载的文件大小减少了。精简JavaScript流行的工具有JSMin, YUI Compressor 等。&lt;/p&gt;
&lt;p&gt;还有一种处理JavaScript的方式叫作混淆&lt;/p&gt;
&lt;p&gt;混淆是可以应用在源代码上的另外一种优化方式。和精简一样，它也会移除注释和空白，同时它还会改写代码。作为改写的一部分，函数和变量的名字将被转换为更短的字符串，这时的代码更加精炼。但是会带来三个弊端：可能引入错误、增加调试难度、需要对JavaScript关键字标记. 混淆的效果并不比精简高很多, 所以还是慎重使用吧, 当然现在有一种技术叫 Source Map&lt;/p&gt;
&lt;p&gt;当然了, CSS文件同样可以精简&lt;/p&gt;
&lt;h3 id=&quot;u907F_u514D_u91CD_u5B9A_u5411&quot;&gt;&lt;a href=&quot;#u907F_u514D_u91CD_u5B9A_u5411&quot; class=&quot;headerlink&quot; title=&quot;避免重定向&quot;&gt;&lt;/a&gt;避免重定向&lt;/h3&gt;&lt;p&gt;重定向用于将用户从一个URL重新路由到另一个URL，种类有很多，常用的是301和302。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。 &lt;/p&gt;
&lt;p&gt;重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。&lt;/p&gt;
&lt;p&gt;重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用 Alias 和 mod_rewrite ，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合 Alias 或者 mod_rewrite 指令。&lt;/p&gt;
&lt;h3 id=&quot;u5220_u9664_u91CD_u590D_u811A_u672C&quot;&gt;&lt;a href=&quot;#u5220_u9664_u91CD_u590D_u811A_u672C&quot; class=&quot;headerlink&quot; title=&quot;删除重复脚本&quot;&gt;&lt;/a&gt;删除重复脚本&lt;/h3&gt;&lt;p&gt;开发一个网站需要极大数量的资源，除了核心团队要构建网站外，其他团队也会向页面贡献HTML代码。由于来自不同团队的很多人都要向页面中添加HTML，很容易想到相同的脚本可能会被添加多次&lt;/p&gt;
&lt;p&gt;重复脚本会伤害性能—引起不必要的HTTP请求和执行JavaScript所消耗的时间&lt;/p&gt;
&lt;h3 id=&quot;u914D_u7F6EETag&quot;&gt;&lt;a href=&quot;#u914D_u7F6EETag&quot; class=&quot;headerlink&quot; title=&quot;配置ETag&quot;&gt;&lt;/a&gt;配置ETag&lt;/h3&gt;&lt;p&gt;实体标签（Entity Tag，ETag）是Web服务器和浏览器用于确认缓存组件的有效性的一种机制。减少呈现页面时所必需的HTTP请求的数量是加速用户体验的最佳方式。可以通过最大化浏览器缓存组件的能力来实现这一目标，但当网站被宿主在多于一台服务器上时，ETag头可能会阻碍缓存。&lt;/p&gt;
&lt;p&gt;ETag带来的问题 ETag的问题在于，通常使用组件的某些属性来构造它，这些属性对于特定的、寄宿了网站的服务器来说是唯一的。当浏览器从一台服务器上获取了原始组件，之后又向另外一台不同的服务器发起条件GET请求时，ETag是不会匹配的—-而对于使用服务器集群来处理请求的网站来说，这是很常见的一种情况。默认情况下，对于拥有多台服务器的网站，Apache和IIS向ETag中嵌入的数据都会大大地降低有效性验证的成功率。    &lt;/p&gt;
&lt;p&gt;解决该问题的两种方式：选择ETag的配置方式或者直接移除ETag&lt;/p&gt;
&lt;h3 id=&quot;u4F7FAjax_u53EF_u7F13_u5B58&quot;&gt;&lt;a href=&quot;#u4F7FAjax_u53EF_u7F13_u5B58&quot; class=&quot;headerlink&quot; title=&quot;使Ajax可缓存&quot;&gt;&lt;/a&gt;使Ajax可缓存&lt;/h3&gt;&lt;p&gt;改善Ajax请求的最重要的方式就是使响应可缓存, 下面的规则同样适用于Ajax：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gzip组件
减少DNS查找
压缩JavaScript
避免重定向
配置ETags
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u6743_u8861&quot;&gt;&lt;a href=&quot;#u6743_u8861&quot; class=&quot;headerlink&quot; title=&quot;权衡&quot;&gt;&lt;/a&gt;权衡&lt;/h3&gt;&lt;p&gt;当我们做性能优化时, 不要浪费时间尝试为那些不消耗大量时间的代码提速. 评估优先, 拒绝任何不能提供良好效益的优化.&lt;/p&gt;
&lt;p&gt;通常来说, 减少JavaScript循环的次数与循环增量的开销, 和优化对DOM的操作是值得的&lt;/p&gt;
&lt;h3 id=&quot;u7B80_u5316CSS_u64CD_u4F5C_u7B26&quot;&gt;&lt;a href=&quot;#u7B80_u5316CSS_u64CD_u4F5C_u7B26&quot; class=&quot;headerlink&quot; title=&quot;简化CSS操作符&quot;&gt;&lt;/a&gt;简化CSS操作符&lt;/h3&gt;&lt;p&gt;什么是高效的选择符&lt;/p&gt;
&lt;p&gt;看看如下规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#toc &amp;gt; li {font-weight: bold};
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大多数人会认为浏览器是从左到右匹配规则的, 因此会推测这条规则的开销不高. &lt;strong&gt;事实上,CSS选择符是从右到左匹配的&lt;/strong&gt;, 因此上边的规则开销实际上相当高, 浏览器必须遍历每个li元素并确定它们的父元素 id 是不是 toc; 如果是后代选择器的话性能消耗会更大.&lt;/p&gt;
&lt;p&gt;编写高效的CSS选择符&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免使用通配符&lt;/li&gt;
&lt;li&gt;不要限定ID选择符&lt;/li&gt;
&lt;li&gt;不要限定类选择符&lt;/li&gt;
&lt;li&gt;让规则越具体越好&lt;/li&gt;
&lt;li&gt;避免使用后代选择符&lt;/li&gt;
&lt;li&gt;避免使用标签-子选择符&lt;/li&gt;
&lt;li&gt;依靠继承&lt;/li&gt;
&lt;li&gt;关注关键选择符(即最右边的选择符参数, 它对开销起了主要影响)&lt;/li&gt;
&lt;li&gt;关注回流的影响&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;糟糕的选择符对性能影响有多大&lt;/p&gt;
&lt;p&gt;毫无疑问复杂的选择符会影响性能, 但实际上优化后的CSS选择符减少的开销是微不足道的, 并且CSS选择符的影响对规则和DOM元素的数量增长是非线性的; 在IE7中那些高开销的子代与后代选择符只有超过 18000 条开销才会突然升高(实际开发中基本不可能匹配到如此多的规则), 并且现代高级浏览器对选择符进行了优化&lt;/p&gt;
&lt;p&gt;最佳实践&lt;/p&gt;
&lt;p&gt;如果你要兼容低版本IE浏览器, 编写高效的选择符是有必要的,&lt;br&gt;但是编写高效的选择符本身也需要成本: 增加页面成本, 降低样式灵活性等,&lt;br&gt;而在主流浏览器中选择符性能已经被极大提速, 绝大部分你都可以按自己的习惯来书写&lt;/p&gt;
&lt;p&gt;这需要你的权衡&lt;/p&gt;
&lt;h3 id=&quot;u7BA1_u7406_u5185_u5B58&quot;&gt;&lt;a href=&quot;#u7BA1_u7406_u5185_u5B58&quot; class=&quot;headerlink&quot; title=&quot;管理内存&quot;&gt;&lt;/a&gt;管理内存&lt;/h3&gt;&lt;p&gt;尽量少的使用内存, 手动解除对内存的引用, 清除不用的对象; 虽然浏览器会回收不用的内存, 但在老旧的浏览器中并不是那么完美, 还会有一些意外的问题; 幸运的是最新的浏览器已经做到非常好了&lt;/p&gt;
&lt;h3 id=&quot;u7F16_u5199_u9AD8_u6548_u7684JavaScript&quot;&gt;&lt;a href=&quot;#u7F16_u5199_u9AD8_u6548_u7684JavaScript&quot; class=&quot;headerlink&quot; title=&quot;编写高效的JavaScript&quot;&gt;&lt;/a&gt;编写高效的JavaScript&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;管理作用域非常重要, 因为存取非局部变量要比局部变量耗时更多. 尽量避免使用会正常作用域链的结构, 比如使用 with 语句和try-catch语句中的 catch 从句. 如果非局部变量的使用超过一次, 那么为了降低性能损耗, 就应该将它存储到一个局部变量中.&lt;/li&gt;
&lt;li&gt;存储和读取数据的方式对脚本性能影响极大. 字面量和局部变量最是最快的; 存取数组元素和对象属性会引起性能损耗. 如果数组元素或对象属性的使用超过一次, 那么为了提高存取速度, 就应该将它存储到一个局部变量中&lt;/li&gt;
&lt;li&gt;条件判断有三种处理方式: if语句 switch 语句和数组查找. if 语句适用于少量离散值或一段区间值得判断; switch语句最好用于3-10个离散值的判断; 数组查找在处理大量离散值时效率最高.(如非必要, 不要使用for in 循环)&lt;/li&gt;
&lt;li&gt;在JavaScript中, 循环经常会成为性能瓶颈. 为了是循环最高效, 可以使用倒序的方式来处理元素. 如果必须要进行大量的迭代, 还可以考虑Duff策略来提高执行速度(只在IE6 7 8 中有明显的效果).&lt;/li&gt;
&lt;li&gt;谨慎使用HTMLCollection对象. 每次存取这类对象的属性, 都会重新查询DOM 中匹配的节点. 为了避免这种高昂的开销, 只有在必要时才存取  HTMLCollection对象, 并将经常存取的值(例如length属性) 存储在局部变量中.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u5C3D_u91CF_u5C11_u7528iframe&quot;&gt;&lt;a href=&quot;#u5C3D_u91CF_u5C11_u7528iframe&quot; class=&quot;headerlink&quot; title=&quot;尽量少用iframe&quot;&gt;&lt;/a&gt;尽量少用iframe&lt;/h3&gt;&lt;p&gt; 优点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;引入缓慢的第三方内容，比如标志和广告
安全沙箱
并行下载脚本
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 缺点&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;代价高昂，即使是空白的iframe
阻塞页面加载
非语义
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u56FE_u50CF_u4F18_u5316&quot;&gt;&lt;a href=&quot;#u56FE_u50CF_u4F18_u5316&quot; class=&quot;headerlink&quot; title=&quot;图像优化&quot;&gt;&lt;/a&gt;图像优化&lt;/h3&gt;&lt;h3 id=&quot;u534F_u5546_u7F13_u5B58_u6D41_u7A0B_u56FE&quot;&gt;&lt;a href=&quot;#u534F_u5546_u7F13_u5B58_u6D41_u7A0B_u56FE&quot; class=&quot;headerlink&quot; title=&quot;协商缓存流程图&quot;&gt;&lt;/a&gt;协商缓存流程图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/cache.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;u603B_u7ED3&quot;&gt;&lt;a href=&quot;#u603B_u7ED3&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;所有的优化都和可以总结为一下几方面:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少HTTP请求, 包括减少HTTP的请求次数, 减少HTTP的请求响应时间,  减少HTTP请求的内容的大小&lt;/li&gt;
&lt;li&gt;优化加载时用户体验&lt;/li&gt;
&lt;li&gt;优化用户操作时的体验&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u6CE8&quot;&gt;&lt;a href=&quot;#u6CE8&quot; class=&quot;headerlink&quot; title=&quot;注&quot;&gt;&lt;/a&gt;注&lt;/h3&gt;&lt;p&gt;有许多优化都是基于浏览器, 得益于浏览器的高速发展, 以前许多需要复杂方法(其实我也没仔细看, 貌似很厉害的样子)&lt;br&gt;实现的优化都已经不再适用, 因为浏览器已经实现那些功能, 所以也没有列出来.&lt;/p&gt;
&lt;p&gt;什么时候IE9甚至IE11之前版本的浏览器能在国内消失, 那真是要好好庆贺一番 &lt;/p&gt;
&lt;h3 id=&quot;u53C2_u8003&quot;&gt;&lt;a href=&quot;#u53C2_u8003&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&amp;lt;&amp;lt;高性能网站建设指南&amp;gt;&amp;gt;&lt;br&gt;&amp;lt;&amp;lt;高性能网站建设进阶指南&amp;gt;&amp;gt;&lt;br&gt;这两本书是如此的经典, 即使在许多年后的今天仍然有非常大的参考价值, 可能一些旧的技术已经落后, 更好更新的技术不断的出现, 但其中体现的思想却不会过时&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u6027_u80FD_u9EC4_u91D1_u6CD5_u5219&quot;&gt;&lt;a href=&quot;#u6027_u80FD_u9EC4_u91D1_u6CD5_u5219&quot; class=&quot;headerlink&quot; title=&quot;性能黄金法则&quot;&gt;&lt;/a&gt;性能黄金法则&lt;/h3
    
    </summary>
    
      <category term="web" scheme="http://HeartWalker.cc/categories/web/"/>
    
    
      <category term="优化" scheme="http://HeartWalker.cc/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>js作用域其四:闭包</title>
    <link href="http://HeartWalker.cc/2016/04/06/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%85%B6%E5%9B%9B-%E9%97%AD%E5%8C%85/"/>
    <id>http://HeartWalker.cc/2016/04/06/js作用域其四-闭包/</id>
    <published>2016-04-05T17:37:41.000Z</published>
    <updated>2016-04-09T13:44:52.466Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u4EC0_u4E48_u662F_u95ED_u5305&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u95ED_u5305&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h3&gt;&lt;p&gt;闭包就是受保护的变量空间, 在JavaScript中就是将变量包裹在函数中, 禁止外部访问&lt;/p&gt;
&lt;h3 id=&quot;u4E3A_u4EC0_u4E48_u8981_u7528_u95ED_u5305&quot;&gt;&lt;a href=&quot;#u4E3A_u4EC0_u4E48_u8981_u7528_u95ED_u5305&quot; class=&quot;headerlink&quot; title=&quot;为什么要用闭包&quot;&gt;&lt;/a&gt;为什么要用闭包&lt;/h3&gt;&lt;p&gt;闭包的主要应用就是特权方法，特权方法能够让外界对函数内部的私有变量进行受限制的访问.这一特性在某些项目的开发中会非常常见.&lt;/p&gt;
&lt;h3 id=&quot;u95ED_u5305_u600E_u4E48_u7528&quot;&gt;&lt;a href=&quot;#u95ED_u5305_u600E_u4E48_u7528&quot; class=&quot;headerlink&quot; title=&quot;闭包怎么用&quot;&gt;&lt;/a&gt;闭包怎么用&lt;/h3&gt;&lt;p&gt;创建闭包的常见方式，就是在一个函数内部创建另一个函数，然后通过 return 将需要访问的私有变量返回出来 例:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;fo&lt;/span&gt;&lt;/span&gt; ()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var num = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;set&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (n)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            num = n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        get: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt; ()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; num;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var f = fo();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;f.set(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var m = f.get();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(m);  //&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在全局环境中只能使用特权方法 set 与 get 设置与得到函数中的 num 值&lt;/p&gt;
&lt;h3 id=&quot;u95ED_u5305_u7684_u4F18_u7F3A_u70B9__uFF1A&quot;&gt;&lt;a href=&quot;#u95ED_u5305_u7684_u4F18_u7F3A_u70B9__uFF1A&quot; class=&quot;headerlink&quot; title=&quot;闭包的优缺点 ：&quot;&gt;&lt;/a&gt;闭包的优缺点 ：&lt;/h3&gt;&lt;p&gt;优点：不产生全局变量，实现属性私有化.&lt;br&gt;缺点：闭包中的数据会常驻内存，在不用的时候要手动删除，否则可能会导致内存溢出.&lt;br&gt;例如在上边代码中, f始终包含fo 中匿名函数的引用 , 导致匿名函数的作用域始终存在.  更好的做法是在函数调用完成之后解除对匿名函数的引用,  例如在上边的代码中最后加上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f = null;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;u95ED_u5305_u4E0E_u53D8_u91CF&quot;&gt;&lt;a href=&quot;#u95ED_u5305_u4E0E_u53D8_u91CF&quot; class=&quot;headerlink&quot; title=&quot;闭包与变量&quot;&gt;&lt;/a&gt;闭包与变量&lt;/h3&gt;&lt;p&gt;由于作用域链的配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的 后一个值. 别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量下面这个例子可以清晰地说明这个问题:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var arr =   [   &amp;#123;   name:   &lt;span class=&quot;string&quot;&gt;&#39;jim&#39;&lt;/span&gt;   &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;   name:   &lt;span class=&quot;string&quot;&gt;&#39;tom&#39;&lt;/span&gt;   &amp;#125;,                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;   name:   &lt;span class=&quot;string&quot;&gt;&#39;jack&#39;&lt;/span&gt;  &amp;#125;,                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;   name:   &lt;span class=&quot;string&quot;&gt;&#39;clark&#39;&lt;/span&gt; &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         ]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //赋值循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;  (var i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;  i &amp;lt; arr.length; i++ ) &amp;#123;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    arr[i].sayHellow  =   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt; ()  &amp;#123;                               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log( arr[ i ].name  );              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //输出循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( var k  &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;  arr )   &amp;#123;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        arr[ k ].sayHellow(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 表面上看，赋值循环给数组arr的每一项添加了一个sayHellow方法, 该方法能输出数组中每一项的name属性 ,然而实际上这段代码会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Uncaught TypeError: Cannot read property &amp;apos;name&amp;apos; of undefined(…)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在赋值循环给数组 arr 中的每一项添加属性时实际上是赋值的函数体, 匿名函数并没有执行; 当输出循环时才执行匿名函数, 因为匿名函数内并没有 i, 所以会向作用域链的下一级查找, 在这段代码中就是全局环境, 全局环境中的 i 执行完赋值循环后的值是 4, 所以数组arr中每一项的 sayHellow方法都是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function (){
    console.log(arr[4].name);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;很明显数组并没有arr[4]存在, 所以报错&lt;/p&gt;
&lt;p&gt;解决这个问题最简单的方法是用 this&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var arr =   [   &amp;#123;   name:   &lt;span class=&quot;string&quot;&gt;&#39;jim&#39;&lt;/span&gt;   &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &amp;#123;   name:   &lt;span class=&quot;string&quot;&gt;&#39;tom&#39;&lt;/span&gt;   &amp;#125;,                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &amp;#123;   name:   &lt;span class=&quot;string&quot;&gt;&#39;jack&#39;&lt;/span&gt;  &amp;#125;,                                              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               &amp;#123;   name:   &lt;span class=&quot;string&quot;&gt;&#39;clark&#39;&lt;/span&gt; &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            ]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       //赋值循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;  (var i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;  i &amp;lt; arr.length; i++ ) &amp;#123;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       arr[i].sayHellow  =   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt; ()  &amp;#123;                               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       console.log( this.name  );              &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       //输出循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; ( var k  &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt;  arr )   &amp;#123;               &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           arr[ k ].sayHellow(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;关于this将在后面详解&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u4EC0_u4E48_u662F_u95ED_u5305&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u95ED_u5305&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h3&gt;&lt;p&gt;闭包就是受保护的变量
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="作用域" scheme="http://HeartWalker.cc/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>js作用域其三:作用域链</title>
    <link href="http://HeartWalker.cc/2016/04/05/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%85%B6%E4%B8%89-%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <id>http://HeartWalker.cc/2016/04/05/js作用域其三-作用域链/</id>
    <published>2016-04-04T16:25:32.000Z</published>
    <updated>2016-04-09T11:00:48.953Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u4EC0_u4E48_u662F_u4F5C_u7528_u57DF_u94FE&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u4F5C_u7528_u57DF_u94FE&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域链&quot;&gt;&lt;/a&gt;什么是作用域链&lt;/h3&gt;&lt;p&gt;每一个变量都有自己的作用域, 全局变量可以再任何地方被访问到, 而局部变量只能在其作用域内被访问到, 例:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var o = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;b&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var B =&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;C&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var c = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;　　可以在全局环境访问o, 在函数A与B之间访问o与a, 在函数B与C之间访问o与a和b, 在函数C中访问o与a和b与c.&lt;br&gt;　　当代码在一个环境中执行时，会创建变量对象的的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。———–引自Javascript高级程序设计（第三版）（P73）&lt;br&gt;　　对于一个变量时, 作用域链的最顶端就是当前的函数环境, 下一级就是包含这个变量的下一个函数环境… 直到最后全局环境为止&lt;br&gt;简而言之作用域链就是变量其执行环境按生效的顺序形成的一种链式结构&lt;/p&gt;
&lt;h3 id=&quot;u7ED8_u5236_u4F5C_u7528_u57DF_u94FE&quot;&gt;&lt;a href=&quot;#u7ED8_u5236_u4F5C_u7528_u57DF_u94FE&quot; class=&quot;headerlink&quot; title=&quot;绘制作用域链&quot;&gt;&lt;/a&gt;绘制作用域链&lt;/h3&gt;&lt;p&gt;绘制作用域链可以清晰的理清代码的结构, 并且在代码执行的时候, 能去准确的定位应该改变的变量的位置&lt;br&gt;绘制原型链的规则:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将全部的&amp;lt; script &amp;gt;标签看做一个整体. 是一个 0 级别的链, 链中所有的全局范围内的变量, 函数, 对象… 都是链中的成员, 由于声明会提升, 因此在绘制链之前将代码可以进行调整, 在开始的时候, 将声明都写在前面, 绘图的时候按照顺序绘制, 较为简单.&lt;/li&gt;
&lt;li&gt;由于只有函数才可以限定作用域. 因此在函数上引出一条新链, 级别为 n + 1, 在函数内部, 又是一个完整, 独立的作用域结构, 因此在函数内部定义的任何成员也按照 1 中的规则在该链上展开&lt;/li&gt;
&lt;li&gt;如果有函数, 继续绘制下去&lt;br&gt;注: 由于函数声明提升在不同的&amp;lt; script &amp;gt;标签中并不起作用, 需要注意&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u5229_u7528_u4F5C_u7528_u57DF_u94FE_u641C_u7D22_u53D8_u91CF&quot;&gt;&lt;a href=&quot;#u5229_u7528_u4F5C_u7528_u57DF_u94FE_u641C_u7D22_u53D8_u91CF&quot; class=&quot;headerlink&quot; title=&quot;利用作用域链搜索变量&quot;&gt;&lt;/a&gt;利用作用域链搜索变量&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在代码的执行过程中, 如果访问到某一个变量, 那么首先在当前链上找 ( 无序 )&lt;/li&gt;
&lt;li&gt;如果没有, 在 n-1 级上找( 在函数内部允许访问定义在函数外部的变量 ). &lt;/li&gt;
&lt;li&gt;如此往复, 直到 0 级链, 如果还没有, 抛出异常; 如果找到, 则结束寻找, 直接获得该链上变量的数据&lt;/li&gt;
&lt;li&gt;不允许跨链查找&lt;h3 id=&quot;u56FE_u4F8B&quot;&gt;&lt;a href=&quot;#u56FE_u4F8B&quot; class=&quot;headerlink&quot; title=&quot;图例&quot;&gt;&lt;/a&gt;图例&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var a = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var f = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var n = &lt;span class=&quot;number&quot;&gt;456&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var o = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var arr = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var f = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var d= &lt;span class=&quot;number&quot;&gt;000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var arr = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var fo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            a= &lt;span class=&quot;number&quot;&gt;456&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fo(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(a);  //&lt;span class=&quot;number&quot;&gt;456&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;绘制其作用链图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/zyyl1.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;执行fo(), 执行a = 456; 在fo的1级链没有定义a ,于是向0级链查找; 0级链定义了a, 于是给其赋值456.&lt;br&gt;如果改变代码, 在函数fo内声明a ,如下:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var a = &lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var f = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var n = &lt;span class=&quot;number&quot;&gt;456&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var o = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var arr = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var f = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var d= &lt;span class=&quot;number&quot;&gt;000&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var arr = [];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var fo = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a= &lt;span class=&quot;number&quot;&gt;456&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fo(); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(a);  //&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;绘制其作用链图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/zyyl2.gif&quot; alt=&quot;&quot;&gt;&lt;br&gt;执行fo(), 执行a = 456; 在fo的1级链定义了a, 于是给其赋值456, 然后结束查找, 全局作用域的a 的值并没有改变&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u4EC0_u4E48_u662F_u4F5C_u7528_u57DF_u94FE&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u4F5C_u7528_u57DF_u94FE&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域链&quot;&gt;&lt;
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="作用域" scheme="http://HeartWalker.cc/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>js作用域其二:预解析</title>
    <link href="http://HeartWalker.cc/2016/04/04/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%85%B6%E4%BA%8C-%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    <id>http://HeartWalker.cc/2016/04/04/js作用域其二-预解析/</id>
    <published>2016-04-04T05:48:07.000Z</published>
    <updated>2016-04-04T11:41:47.603Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u89E3_u6790_u673A_u5236&quot;&gt;&lt;a href=&quot;#u89E3_u6790_u673A_u5236&quot; class=&quot;headerlink&quot; title=&quot;解析机制&quot;&gt;&lt;/a&gt;解析机制&lt;/h3&gt;&lt;p&gt;JavaScript是一门解释型的语言 , 想要运行js代码需要两个阶段&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译阶段: 编译阶段就是我们常说的JavaScript预解析（预处理）阶段，在这个阶段JavaScript解释器将完成把JavaScript脚本代码转换到字节码&lt;/li&gt;
&lt;li&gt;执行阶段: 在编译阶段JavaScript解释器借助执行环境把字节码生成机械码，并从上到下按顺序执行&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;u9884_u89E3_u6790_u65F6_u505A_u4EC0_u4E48&quot;&gt;&lt;a href=&quot;#u9884_u89E3_u6790_u65F6_u505A_u4EC0_u4E48&quot; class=&quot;headerlink&quot; title=&quot;预解析时做什么&quot;&gt;&lt;/a&gt;预解析时做什么&lt;/h3&gt;&lt;h4 id=&quot;var__2C_function_u58F0_u660E_u7684_u53D8_u91CF_u63D0_u5347&quot;&gt;&lt;a href=&quot;#var__2C_function_u58F0_u660E_u7684_u53D8_u91CF_u63D0_u5347&quot; class=&quot;headerlink&quot; title=&quot;var , function声明的变量提升&quot;&gt;&lt;/a&gt;var , function声明的变量提升&lt;/h4&gt;&lt;p&gt;　　首先，创建一个当前执行环境下的活动对象，然后将用 var 声明的变量设置为活动对象的属性（也就是将其添加到活动对象当中）并将其赋值为undefined，然后将 function 定义的函数 也添加到活动对象当中&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var aa = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var bb = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;BB&lt;/span&gt;&lt;/span&gt;()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;var定义的aa,bb以及function定义的AA(),BB()都会被变量提升到window对象下面 提升后等同于如下代码:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var aa;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var bb;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;BB&lt;/span&gt;&lt;/span&gt;()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    aa = &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    bb = &lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注: 不是用var 定义的变量具有全局性, 但是并不会被提升, 只有在第一次执行到时才会出现在全局作用域中&lt;/p&gt;
&lt;h4 id=&quot;u51FD_u6570_u58F0_u660E_u4E0E_u51FD_u6570_u8868_u8FBE_u5F0F_u5728_u9884_u89E3_u6790_u7684_u533A_u522B&quot;&gt;&lt;a href=&quot;#u51FD_u6570_u58F0_u660E_u4E0E_u51FD_u6570_u8868_u8FBE_u5F0F_u5728_u9884_u89E3_u6790_u7684_u533A_u522B&quot; class=&quot;headerlink&quot; title=&quot;函数声明与函数表达式在预解析的区别&quot;&gt;&lt;/a&gt;函数声明与函数表达式在预解析的区别&lt;/h4&gt;&lt;p&gt;　　首先，我们知道解析器会对function定义的函数（也就是函数声明）在代码开始执行之前对其实行函数声明提升（function declaration hoisting），所以在函数声明之前调用该函数是不会在执行期间报错，但是函数表达式不同，函数表达式用 var 声明，也就是说解析器会对其变量提升，并对其赋值为undefined，然后在执行期间，等到执行到该var 变量的时候再将其变量指向一个function函数，所以在函数表达式之前执行该函数是会报错的。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AA();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BB();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var BB = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;AA();不会报错，因为是以function的变量提升，BB()会报错，因为是以var的变量提升，提升后代码等同于如下:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var BB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AA();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BB();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BB = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注意: &lt;font color=&quot;red&quot;&gt;函数声明提升以后并不会执行内部的代码, 在其内的变量声明也不会起作用, 而是等到函数第一次被调用时才会执行&lt;/font&gt; 如:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var AA = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(&lt;span class=&quot;string&quot;&gt;&#39; AA &#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;BB&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(&lt;span class=&quot;string&quot;&gt;&#39; BB &#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;单独这一段代码并不会起作用, 只有执行:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AA(); // 输出 AA&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BB(); //输出 BB&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;function__u8986_u76D6&quot;&gt;&lt;a href=&quot;#function__u8986_u76D6&quot; class=&quot;headerlink&quot; title=&quot;function 覆盖&quot;&gt;&lt;/a&gt;function 覆盖&lt;/h4&gt;&lt;p&gt;　若定义了两个同名的函数，则在预解析期间后面一个会覆盖签名一个&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AA();   // 输出 I am AA_2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(&lt;span class=&quot;string&quot;&gt;&#39;I am AA_1&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AA();  // 输出 I am AA_2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&lt;span class=&quot;string&quot;&gt;&#39;I am AA_2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;提升后其代码等同于如下:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(&lt;span class=&quot;string&quot;&gt;&#39;I am AA_1&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&lt;span class=&quot;string&quot;&gt;&#39;I am AA_2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AA();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AA();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到这是正常的函数声明覆盖 &lt;/p&gt;
&lt;h4 id=&quot;u9884_u89E3_u6790_u628A_u53D8_u91CF_u6216_u51FD_u6570_u89E3_u6790_u5230_u5176_u8FD0_u884C_u65F6_u7684_u73AF_u5883_u4E2D&quot;&gt;&lt;a href=&quot;#u9884_u89E3_u6790_u628A_u53D8_u91CF_u6216_u51FD_u6570_u89E3_u6790_u5230_u5176_u8FD0_u884C_u65F6_u7684_u73AF_u5883_u4E2D&quot; class=&quot;headerlink&quot; title=&quot;预解析把变量或函数解析到其运行时的环境中&quot;&gt;&lt;/a&gt;预解析把变量或函数解析到其运行时的环境中&lt;/h4&gt;&lt;p&gt;解析器将变量提升并不是将所有的变量都提升到window对象下面，其提升的原则是提升到变量运行的环境(&lt;strong&gt;变量生效的词法作用域&lt;/strong&gt;)顶端&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;aa = &lt;span class=&quot;string&quot;&gt;&quot;I am aa&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(aa);             // 输出 aa 是 undefined&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var aa = &lt;span class=&quot;string&quot;&gt;&quot;I am aa in a function&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(aa);             //输出 aa 是 I am aa &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AA();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里 aa 被变量提升，但是aa 没有被变量提升到 window下面，而是被提升到其运行的环境 (function(){ })() 中去，也就是等同于&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;aa = &lt;span class=&quot;string&quot;&gt;&quot;I am aa&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    var aa;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(aa);          // 输出 aa 是 undefined&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    aa = &lt;span class=&quot;string&quot;&gt;&quot;I am aa in a function&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(aa);          //输出 aa 是 I am aa &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; a &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AA();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&quot;JavaScript_u201C_u9884_u89E3_u6790_u201D_u5206_u6BB5_u8FDB_u884C&quot;&gt;&lt;a href=&quot;#JavaScript_u201C_u9884_u89E3_u6790_u201D_u5206_u6BB5_u8FDB_u884C&quot; class=&quot;headerlink&quot; title=&quot;JavaScript“预解析”分段进行&quot;&gt;&lt;/a&gt;JavaScript“预解析”分段进行&lt;/h4&gt;&lt;p&gt;所谓分段进行是按照&amp;lt; script &amp;gt;标签来分块进行预解析&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AA();  // 输出 AA2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(&lt;span class=&quot;string&quot;&gt;&#39;AA1&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(&lt;span class=&quot;string&quot;&gt;&#39;AA2&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;AA&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   console.log(&lt;span class=&quot;string&quot;&gt;&#39;AA3&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面例子说明function函数声明是分块的，然而至于var变量的提升经过反复验证是不分块的( 此处如有不同意见请指教 )&lt;/p&gt;
&lt;h3 id=&quot;u53C2_u8003&quot;&gt;&lt;a href=&quot;#u53C2_u8003&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/HPNiuYear/archive/2012/08/27/2657879.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;javascript解析机制——预解析&lt;/a&gt;&lt;br&gt;本文是在此篇博客的基础上进行了修改与扩充&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u89E3_u6790_u673A_u5236&quot;&gt;&lt;a href=&quot;#u89E3_u6790_u673A_u5236&quot; class=&quot;headerlink&quot; title=&quot;解析机制&quot;&gt;&lt;/a&gt;解析机制&lt;/h3&gt;&lt;p&gt;JavaScript是一门解释型的语言 , 想要
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="作用域" scheme="http://HeartWalker.cc/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>js作用域其一:概念详细</title>
    <link href="http://HeartWalker.cc/2016/04/04/js%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%85%B6%E4%B8%80-%E6%A6%82%E5%BF%B5%E8%AF%A6%E7%BB%86/"/>
    <id>http://HeartWalker.cc/2016/04/04/js作用域其一-概念详细/</id>
    <published>2016-04-03T16:19:58.000Z</published>
    <updated>2016-04-06T04:39:02.064Z</updated>
    
    <content type="html">&lt;h3 id=&quot;u4EC0_u4E48_u662F_u4F5C_u7528_u57DF&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u4F5C_u7528_u57DF&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域&quot;&gt;&lt;/a&gt;什么是作用域&lt;/h3&gt;&lt;p&gt;顾名思义, 作用域就变量是起作用的区域, 作用域约束了定义变量后可以使用它的范围, 在编程语言中常见的作用域规则有: 块级作用域与词法作用域&lt;/p&gt;
&lt;h3 id=&quot;u5757_u7EA7_u4F5C_u7528_u57DF&quot;&gt;&lt;a href=&quot;#u5757_u7EA7_u4F5C_u7528_u57DF&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h3&gt;&lt;p&gt;所谓的块级作用域就是用块将变量分隔, 在块中定义的所有变量在代码块外都是不可见的, 通常块指的就是一对{}, 大多数C系语言都有块级作用域, 但在JavaScript中并没有这个规则. 例:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//C语言 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;/span&gt;() &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int i=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int j=&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;printf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;%d/n&quot;&lt;/span&gt;,j); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;会报 error: ‘j’ undeclared (first use in this function),因为 C语言拥有块级作用域，因为j是在if的语句块中定义的，因此，它在块外是无法访问的.&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//JavaScript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i)&amp;#123;var j =&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(j);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;控制台输出3, 可见在块级作用域{}之外j仍能访问.&lt;/p&gt;
&lt;h3 id=&quot;u8BCD_u6CD5_u4F5C_u7528_u57DF&quot;&gt;&lt;a href=&quot;#u8BCD_u6CD5_u4F5C_u7528_u57DF&quot; class=&quot;headerlink&quot; title=&quot;词法作用域&quot;&gt;&lt;/a&gt;词法作用域&lt;/h3&gt;&lt;p&gt;词法作用域又称为函数作用域, 就是变量的做用范围在书写代码的时候已经决定, 与运行的时候无关, 在JavaScript中用的便是词法作用域的规则, 分隔词法作用域的只有函数, 函数内部允许访问函数外部的变量. 例:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//JavaScript&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;/span&gt;()&amp;#123;var i =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; f();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; console.log(i);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt; 控制台会报错, Uncaught ReferenceError: i is not defined(…), 因为i 只在词法作用域函数f内生效, 例:&lt;br&gt; &lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;/span&gt;()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   var i =&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;console.log(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   f();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;控制台输出1 &lt;/p&gt;
&lt;h3 id=&quot;u5168_u5C40_u53D8_u91CF_u4E0E_u5C40_u90E8_u53D8_u91CF&quot;&gt;&lt;a href=&quot;#u5168_u5C40_u53D8_u91CF_u4E0E_u5C40_u90E8_u53D8_u91CF&quot; class=&quot;headerlink&quot; title=&quot;全局变量与局部变量&quot;&gt;&lt;/a&gt;全局变量与局部变量&lt;/h3&gt;&lt;p&gt;全局变量指的是在整个window下都可以生效的变量, 所有不在词法作用域内声明的变量都是全局变量; 局部变量指的就是在词法作用域内用var声明的变量, 但是不用var声明的变量(如:a = 1;)则具有全局性, 词法作用域内的变量必须要函数执行以后才能生效&lt;br&gt;全局变量可以再任何地方访问到, 为局部变量只能在其作用域内被访问到&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u4EC0_u4E48_u662F_u4F5C_u7528_u57DF&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662F_u4F5C_u7528_u57DF&quot; class=&quot;headerlink&quot; title=&quot;什么是作用域&quot;&gt;&lt;/a&gt;什么是作用域&lt;/h3
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="作用域" scheme="http://HeartWalker.cc/tags/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客完工感言</title>
    <link href="http://HeartWalker.cc/2016/04/02/hexo%E5%8D%9A%E5%AE%A2%E5%AE%8C%E5%B7%A5%E6%84%9F%E8%A8%80/"/>
    <id>http://HeartWalker.cc/2016/04/02/hexo博客完工感言/</id>
    <published>2016-04-02T04:19:33.000Z</published>
    <updated>2016-04-03T03:02:29.453Z</updated>
    
    <content type="html">&lt;p&gt;　　github pages搞了好久, 然后又设置站内搜索, 设置多说, 同步到coding上, 再买域名, 设置站点地图, 今天算是基本完工了, 大部分想要实现的功能都实现了, 感谢网上的各位乐于分享的博主, 得到了很大的帮助　&lt;br&gt;　　但是不得不吐槽好多坑啊, 有的漏单词, 有的概念没说清, 有的地址没说明白, 有的忽略互相之间的关联,等等… 感觉调bug的时间占到了八成 心塞塞… &lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　github pages搞了好久, 然后又设置站内搜索, 设置多说, 同步到coding上, 再买域名, 设置站点地图, 今天算是基本完工了, 大部分想要实现的功能都实现了, 感谢网上的各位乐于分享的博主, 得到了很大的帮助　&lt;br&gt;　　但是不得不吐槽好多坑啊, 有的漏
    
    </summary>
    
      <category term="生活" scheme="http://HeartWalker.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="吐槽" scheme="http://HeartWalker.cc/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>国内程序员大不易</title>
    <link href="http://HeartWalker.cc/2016/03/31/%E5%9B%BD%E5%86%85%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A4%A7%E4%B8%8D%E6%98%93/"/>
    <id>http://HeartWalker.cc/2016/03/31/国内程序员大不易/</id>
    <published>2016-03-31T13:33:30.000Z</published>
    <updated>2016-04-01T14:17:12.130Z</updated>
    
    <content type="html">&lt;p&gt;　　在上国过生活工作本来就不易, 体现在程序员身上就更加明显,不仅有错综复杂的人际关系,社会关系, 还要提防祸从口出,天降横祸…&lt;/p&gt;
&lt;p&gt;　　程序员想要学习一些先进的技术,大多是要翻过去的, 奈何墙太高太深, 最近封的越来越厉害,github不翻都经常上不去, 平时像使用npm必须要翻过去,虽有梯子,但总是浪费了许多时间与精力, 本来宝贵的时间就流失了&lt;/p&gt;
&lt;p&gt;　　许多国外的API都不能用, 不久前发现翻过去了某些国内的API连不上了, 当时真是一口老血差点喷出来, 这真是如围城一般&lt;/p&gt;
&lt;p&gt;　　有时我常想国人在办公室政治与xx政治浪费了大量时间,盲目追求利益,并且信息闭塞造成的学习成本太高,这些大抵都是国内技术水平落后的主要原因中的一部分吧&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;　　在上国过生活工作本来就不易, 体现在程序员身上就更加明显,不仅有错综复杂的人际关系,社会关系, 还要提防祸从口出,天降横祸…&lt;/p&gt;
&lt;p&gt;　　程序员想要学习一些先进的技术,大多是要翻过去的, 奈何墙太高太深, 最近封的越来越厉害,github不翻都经常上不去, 平时像
    
    </summary>
    
      <category term="生活" scheme="http://HeartWalker.cc/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="吐槽" scheme="http://HeartWalker.cc/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>一幅图深入理解原型链</title>
    <link href="http://HeartWalker.cc/2016/03/30/%E4%B8%80%E5%B9%85%E5%9B%BE%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://HeartWalker.cc/2016/03/30/一幅图深入理解原型链/</id>
    <published>2016-03-30T14:37:43.000Z</published>
    <updated>2016-04-06T14:20:46.319Z</updated>
    
    <content type="html">&lt;h2 id=&quot;u7EFC_u8FF0&quot;&gt;&lt;a href=&quot;#u7EFC_u8FF0&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;原型是JavaScript中比较难以理解也容易令人困惑的部分,但它又是如此的重要,下边我将用一幅图深入的讲解&lt;/p&gt;
&lt;h2 id=&quot;u539F_u578B_u94FE_u56FE&quot;&gt;&lt;a href=&quot;#u539F_u578B_u94FE_u56FE&quot; class=&quot;headerlink&quot; title=&quot;原型链图&quot;&gt;&lt;/a&gt;原型链图&lt;/h2&gt;&lt;p&gt;  &lt;img src=&quot;/images/proto.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;u6982_u5FF5_u8BE6_u89E3&quot;&gt;&lt;a href=&quot;#u6982_u5FF5_u8BE6_u89E3&quot; class=&quot;headerlink&quot; title=&quot;概念详解&quot;&gt;&lt;/a&gt;概念详解&lt;/h2&gt;&lt;h3 id=&quot;u6784_u9020_u51FD_u6570&quot;&gt;&lt;a href=&quot;#u6784_u9020_u51FD_u6570&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h3&gt;&lt;p&gt;构造函数和普通的函数没有什么不同, 只要通过new操作符来调用就称它为构造函数, 如果不用new操作符调用, 那么它和普通的函数一样; 不过如果在定义一个函数的时候就准备用new调用, 为了区分它一般将构造函数名首字母大写&lt;/p&gt;
&lt;h3 id=&quot;u5B9E_u4F8B_u5BF9_u8C61&quot;&gt;&lt;a href=&quot;#u5B9E_u4F8B_u5BF9_u8C61&quot; class=&quot;headerlink&quot; title=&quot;实例对象&quot;&gt;&lt;/a&gt;实例对象&lt;/h3&gt;&lt;p&gt;如图中f是F()的实例对象, o是Object()的实例对象, 它们通过new操作符来实现; 同时F又是Function()的实例, Object也是Function的实例, 它们是默认的&lt;/p&gt;
&lt;h3 id=&quot;u539F_u578B_u5C5E_u6027prototype&quot;&gt;&lt;a href=&quot;#u539F_u578B_u5C5E_u6027prototype&quot; class=&quot;headerlink&quot; title=&quot;原型属性prototype&quot;&gt;&lt;/a&gt;原型属性prototype&lt;/h3&gt;&lt;p&gt;每一个函数都有原型属性prototype&lt;/p&gt;
&lt;h3 id=&quot;u539F_u578B_u5BF9_u8C61__proto&quot;&gt;&lt;a href=&quot;#u539F_u578B_u5BF9_u8C61__proto&quot; class=&quot;headerlink&quot; title=&quot;原型对象__proto__&quot;&gt;&lt;/a&gt;原型对象__proto__&lt;/h3&gt;&lt;p&gt;对象都有一个内部指针(它是内部属性)指向构造这个对象的函数的原型属性prototype,在高级浏览其中被命名为__proto__, __proto__是一个非标准的属性,在早期的ie中并不被支持,但是为了方便理解, 仍然称它为__proto__&lt;/p&gt;
&lt;h3 id=&quot;constructor-NaN&quot;&gt;&lt;a href=&quot;#constructor-NaN&quot; class=&quot;headerlink&quot; title=&quot;constructor&quot;&gt;&lt;/a&gt;constructor&lt;/h3&gt;&lt;p&gt;每一个构造函数的默认的原型属性中都有一个属性constructor,它是一个指向这个构造函数的引用&lt;/p&gt;
&lt;h2 id=&quot;u5206_u6790&quot;&gt;&lt;a href=&quot;#u5206_u6790&quot; class=&quot;headerlink&quot; title=&quot;分析&quot;&gt;&lt;/a&gt;分析&lt;/h2&gt;&lt;p&gt;如图中对象f是构造函数F()的实例, F有默认的原型属性prototye, prototye中有constructor, constructor指向F, 同时f会自动拥有一个指向F.prototype的属性__proto__&lt;/p&gt;
&lt;h3 id=&quot;u539F_u578B_u94FE_u4E09_u89D2_u5F62&quot;&gt;&lt;a href=&quot;#u539F_u578B_u94FE_u4E09_u89D2_u5F62&quot; class=&quot;headerlink&quot; title=&quot;原型链三角形&quot;&gt;&lt;/a&gt;原型链三角形&lt;/h3&gt;&lt;p&gt;如图与上面分析, 每一个对象都有一个实例它的构造函数与一个默认的__proto__, 该__proto__指向构造函数的prototype, 而在prototype又有一个constructor指挥构造函数,  它们之间就形成了一个三角形,可以称之为原型链三角形, 所有的原型链都有原型链三角形构成的; 可以通过给prototype重新赋值来改变它的指向,此时原型链将被延长,原型链结构将会发生变化,此处暂时不考虑&lt;/p&gt;
&lt;h2 id=&quot;u603B_u7ED3&quot;&gt;&lt;a href=&quot;#u603B_u7ED3&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对象都有原型对象__proto__&lt;/li&gt;
&lt;li&gt;通过构造函数实例的对象的__proto__指向该构造函数的prototype&lt;/li&gt;
&lt;li&gt;函数的原型属性prototype的原型对象__proto__默认是Object.prototye; 而Object.prototype.__proto__指向null&lt;/li&gt;
&lt;li&gt;函数被定义后就有原型属性prototype,原型属性中有默认的属性constructor,constructor指向这个函数&lt;/li&gt;
&lt;li&gt;函数的原型属性也是一个对象,该对象的原型对象__proto__默认继承自Object.prototype&lt;/li&gt;
&lt;li&gt;所有函数都是Function()的实例&lt;/li&gt;
&lt;li&gt;函数本身也是对象,所以它同时又prototype与__proto__&lt;/li&gt;
&lt;li&gt;&lt;strong&gt; Function()是唯一的一个特例,可以认为它是它本身的实例,所以Function.prototype === Function.__proto__ &lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;u7EFC_u8FF0&quot;&gt;&lt;a href=&quot;#u7EFC_u8FF0&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h2&gt;&lt;p&gt;原型是JavaScript中比较难以理解也容易令人困惑的部分,但它又是如此的重要,下边我将用一幅图深入的
    
    </summary>
    
      <category term="js" scheme="http://HeartWalker.cc/categories/js/"/>
    
    
      <category term="原型" scheme="http://HeartWalker.cc/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
</feed>
